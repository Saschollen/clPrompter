<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy"
    content="default-src 'none'; style-src {{cspSource}} 'nonce-{{nonce}}'; script-src 'nonce-{{nonce}}';" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CL Command Prompter</title>
  <style nonce="{{nonce}}">
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      padding: 10px;
    }

    /* ✅ Fix VS Code Elements text visibility */
    vscode-textfield {
      --vscode-input-foreground: var(--vscode-editor-foreground, #000000) !important;
      --vscode-foreground: var(--vscode-editor-foreground, #000000) !important;
      color: var(--vscode-editor-foreground, #000000) !important;
    }

    vscode-single-select {
      --vscode-input-foreground: var(--vscode-editor-foreground, #000000) !important;
      --vscode-foreground: var(--vscode-editor-foreground, #000000) !important;
      color: var(--vscode-editor-foreground, #000000) !important;
    }

    /* ✅ Force text color in shadow DOM (if accessible) */
    vscode-textfield::part(control),
    vscode-single-select::part(control) {
      color: var(--vscode-editor-foreground, #000000) !important;
    }

    /* ✅ Keep placeholder text light */
    vscode-textfield::placeholder,
    vscode-single-select::placeholder {
      color: var(--vscode-input-placeholderForeground, #6c6c6c) !important;
      opacity: 0.7;
    }

    /* ✅ Ensure input text is dark in both light and dark modes */
    vscode-textfield input,
    vscode-single-select input {
      color: var(--vscode-editor-foreground, #000000) !important;
    }

    /* ✅ Enhanced tooltip styles with higher z-index */
    .range-tooltip {
      position: fixed;
      background: #1976d2;
      color: #ffffff;
      border: 1px solid #1565c0;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 13px;
      font-weight: 500;
      z-index: 15000;
      /* ✅ Higher than dropdown z-index (1000) */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      max-width: 320px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease, transform 0.2s ease;
      transform: translateY(-4px);
    }

    .range-tooltip.show {
      opacity: 1;
      transform: translateY(0);
    }

    /* ✅ Arrow pointing up (default) */
    .range-tooltip::before {
      content: '';
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 6px solid #1565c0;
    }

    .range-tooltip::after {
      content: '';
      position: absolute;
      top: -5px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-bottom: 5px solid #1976d2;
    }

    /* ✅ Arrow pointing down (when tooltip appears above input) */
    .range-tooltip.tooltip-above::before {
      top: auto;
      bottom: -6px;
      border-bottom: none;
      border-top: 6px solid #1565c0;
    }

    .range-tooltip.tooltip-above::after {
      top: auto;
      bottom: -5px;
      border-bottom: none;
      border-top: 5px solid #1976d2;
    }

    /* ✅ Enhanced range input states */
    [data-range-from][data-range-to] {
      transition: all 0.3s ease;
      position: relative;
    }

    [data-range-from][data-range-to]:hover {
      box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
    }

    [data-range-from][data-range-to]:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.4);
    }

    [data-range-from][data-range-to].invalid {
      border-color: #d32f2f !important;
      background-color: #ffebee !important;
      box-shadow: 0 0 0 2px rgba(211, 47, 47, 0.3) !important;
    }

    .input-xs {
      width: 80px;
      min-width: 80px;
    }

    /* 1-6 chars (small numbers) */
    .input-sm {
      width: 120px;
      min-width: 120px;
    }

    /* 7-12 chars (medium numbers/names) */
    .input-md {
      width: 200px;
      min-width: 200px;
    }

    /* 13-25 chars (longer names) */
    .input-lg {
      width: 300px;
      min-width: 300px;
    }

    /* 26-50 chars (short descriptions) */
    .input-xl {
      width: 400px;
      min-width: 400px;
    }

    /* 51-80 chars (medium text) */
    .input-full {
      width: 100%;
      min-width: 100%;
    }

    /* 81+ chars (long text/commands) */
    @keyframes shake {

      0%,
      100% {
        transform: translateX(0);
      }

      10%,
      30%,
      50%,
      70%,
      90% {
        transform: translateX(-2px);
      }

      20%,
      40%,
      60%,
      80% {
        transform: translateX(2px);
      }
    }

    /* ✅ Enhanced styling for range validation */
    [data-range-from][data-range-to] {
      transition: all 0.3s ease;
    }

    [data-range-from][data-range-to]:invalid {
      border-color: #ff0000 !important;
      background-color: #ffebee !important;
    }

    .main-container {
      margin-bottom: 1em;
    }

    .label-input {
      width: 12ch;
    }

    .main-title {
      margin-top: 0;
      margin-bottom: 0.5em;
    }

    .parm-multi-group {
      border: 1px dashed #bbb;
      margin-bottom: 1em;
      padding: 0.5em;
    }

    .parm-instance {
      margin-bottom: 0.2em;
      padding-bottom: 0.2em;
      border-bottom: 1px dotted #ddd;
    }

    .add-parm-btn,
    .remove-parm-btn {
      font-size: 0.9em;
      padding: 0 0.3em;
      border-radius: 50%;
      width: 1.5em;
      height: 1.5em;
      min-width: 0;
      min-height: 0;
      line-height: 1;
      vertical-align: middle;
      display: inline-block;
      margin: 0 0.2em 0 0;
      box-sizing: border-box;
      border: 1px solid #888;
      background: #f5f5f5;
    }

    .add-parm-btn:focus,
    .remove-parm-btn:focus {
      outline: none;
      border-color: #0078d4;
    }

    .form-label {
      display: inline-block;
      width: 43ch;
      vertical-align: middle;
      margin-bottom: 0.2em;
    }

    .form-input {
      vertical-align: middle;
      margin-bottom: 0.2em;
    }

    .form-div {
      margin-bottom: 0.2em;
    }

    .elem-group {
      border: 1.5px solid #bbb;
      border-radius: 6px;
      margin-bottom: 0.2em;
      padding: 0.8em 1em 0.2em 1em;
      background: #f8f8f8;
    }

    .elem-group legend {
      font-weight: bold;
      color: #333;
      padding: 0 0.2em;
    }

    button {
      margin-top: 15px;
      font-size: 1.1em;
    }

    .clvar-input {
      margin-left: 0.5em;
      width: 16ch;
    }

    .qual-group .form-label {
      width: auto;
      min-width: 10ch;
      margin-bottom: 0;
      vertical-align: middle;
    }

    .qual-group>div {
      display: flex;
      align-items: center;
      margin-bottom: 0.2em;
      border: 1px dashed red;
      background: #ffe;
    }
  </style>
</head>

<body>

  <script type="module" src="{{vscodeElems}}" nonce="{{nonce}}"></script>


  <h2 id="mainTitle" class="main-title"></h2>
  <div class="main-container">
    <label for="clLabel" class="form-label">Label (optional):</label>
    <input type="text" id="clLabel" maxlength="10" class="label-input" />
  </div>

  <form id="clForm"></form>
  <button id="cancelBtn">Cancel</button>
  <button id="submitBtn">Enter</button>

  <script nonce="{{nonce}}">
    const TOOLTIP_SETTINGS = {
      focusDuration: 3000, // Default 3 seconds for focus tooltips
      errorDuration: 6000, // 6 seconds for error tooltips
      hoverDuration: 2000, // 2 seconds for hover tooltips
      highZIndex: 15000 // High z-index to stay above dropdowns
    };

    let xmlDoc;
    let caseMode = "MONO";
    let parms = [];
    let allowedValsMap = {};
    let cmdName = "{{cmdName}}";
    let originalParamMap = {};
    let vscode;
    let isTestMode = false;

    try {
      vscode = acquireVsCodeApi();
    } catch (e) {
      console.log('[clPrompter] Running in browser test mode (not VS Code)');
      isTestMode = true;

      // Mock VS Code API for testing
      vscode = {
        postMessage: (msg) => console.log('[MOCK] VS Code message:', msg),
        setState: (state) => console.log("[MOCK] Set state:", state),
        getState: () => ({ "[MOCK]": "No state in browser" })
      };

      // ✅ Mock VS Code Elements for Firefox testing
      if (typeof customElements === 'undefined') {
        window.customElements = {
          get: () => null,
          define: () => { },
          keys: function () { return []; }
        };
      }
    }

    console.log("[clPrompter] webview JS loaded");
    // ✅ Update your existing message handler around line 370
    window.addEventListener("message", event => {
      const message = event.data;
      console.log("[clPrompter] Received message:", message.type);

      // ✅ Handle reset message FIRST
      if (message.type === "reset") {
        console.log("[clPrompter] Processing reset message");
        resetPrompterState();
        return;
      }

      // ✅ Handle new formData message with pre-processed allowedValsMap
      if (message.type === "formData") {
        console.log("[clPrompter] Processing formData message");
        const parser = new DOMParser();
        xmlDoc = parser.parseFromString(message.xml, "text/xml");

        // ✅ Use pre-processed allowedValsMap from TypeScript
        allowedValsMap = message.allowedValsMap || {};
        cmdName = message.cmdName || cmdName;

        console.log(`[clPrompter] Updated cmdName to: ${cmdName}`);
        console.log(`[clPrompter] Pre-processed allowedValsMap keys:`, Object.keys(allowedValsMap));

        // Sort parameters
        const allParms = Array.from(xmlDoc.getElementsByTagName("Parm"));
        parms = allParms.sort((a, b) => {
          const aPosNbr = a.getAttribute("PosNbr");
          const bPosNbr = b.getAttribute("PosNbr");
          const aPos = aPosNbr ? parseInt(aPosNbr, 10) : 0;
          const bPos = bPosNbr ? parseInt(bPosNbr, 10) : 0;

          if (aPos === bPos) {
            const aIndex = allParms.indexOf(a);
            const bIndex = allParms.indexOf(b);
            return aIndex - bIndex;
          }
          return aPos - bPos;
        });

        console.log("[clPrompter] Found", parms.length, "parameters");

        setMainTitle();
        loadForm(); // ✅ buildAllowedValsMap() call removed - already done in TypeScript
        console.log("[clPrompter] loadForm completed");
        // Add this right after the form loads in prompter.html
        setTimeout(() => {
          console.log("[clPrompter] DEBUG: All TOPGMQ inputs created:");
          const topgmqInputs = document.querySelectorAll('[name*="TOPGMQ"]');
          topgmqInputs.forEach(input => {
            console.log(`  ${input.tagName}[name="${input.name}"][id="${input.id}"]`);
          });
        }, 1000);
      }

      // ✅ Handle new populateForm message with instructions
      if (message.type === "populateForm") {
        try {
          console.log("[clPrompter] Processing populateForm with instructions");
          console.log('[prompter] Received population instructions:', message.instructions);
          console.log('[prompter] Instructions keys:', Object.keys(message.instructions || {}));

          // Check if instructions contain expected parameters
          if (message.instructions?.MSGID) {
            console.log('[prompter] MSGID instruction:', message.instructions.MSGID);
          }
          // Execute population instructions
          executePopulationInstructions(message.instructions);
        } catch (error) {
          console.error("[clPrompter] Error in populateForm handler:", error);
        }
      }

      // ✅ Existing handlers...
      if (message.type === "setLabel") {
        console.log("[clPrompter] Setting label:", message.label);
        setLabel(message.label);
      }

      // ✅ LEGACY: Handle old formXml for backward compatibility (remove this later)
      if (message.type === "formXml") {
        console.warn("[clPrompter] Received legacy formXml message - this should be migrated to formData");
        const parser = new DOMParser();
        xmlDoc = parser.parseFromString(message.xml, "text/xml");

        // ... existing formXml logic as fallback ...
        buildAllowedValsMap(); // ✅ Keep for now as fallback
        setMainTitle();
        loadForm();
        // Add this right after the form loads in prompter.html
        setTimeout(() => {
          console.log("[clPrompter] DEBUG: All TOPGMQ inputs created:");
          const topgmqInputs = document.querySelectorAll('[name*="TOPGMQ"]');
          topgmqInputs.forEach(input => {
            console.log(`  ${input.tagName}[name="${input.name}"][id="${input.id}"]`);
          });
        }, 1000);
      }
    });

    // ✅ Add this function around line 350 (after global variables)
    function resetPrompterState() {
      console.log("[clPrompter] Resetting prompter state for new command");

      // Clear global state
      xmlDoc = null;
      parms = [];
      allowedValsMap = {};
      originalParamMap = {};

      // Clear the form
      const form = document.getElementById("clForm");
      if (form) {
        form.innerHTML = "";
      }

      // Clear the main title
      const mainTitle = document.getElementById("mainTitle");
      if (mainTitle) {
        mainTitle.textContent = "";
      }

      // Clear the label input
      const labelInput = document.getElementById("clLabel");
      if (labelInput) {
        labelInput.value = "";
      }

      // Hide any tooltips
      if (typeof hideRangeTooltip === 'function') {
        hideRangeTooltip();
      }

      console.log("[clPrompter] Prompter state reset completed");
    }
    function applyCase(val) {
      if (caseMode === "MONO") {
        const trimmed = val.trim();
        if (
          (trimmed.startsWith("'") && trimmed.endsWith("'")) ||
          (trimmed.startsWith('"') && trimmed.endsWith('"'))
        ) {
          return trimmed;
        }
        return trimmed.toUpperCase();
      }
      return val;
    }

    function setLabel(val) {
      const labelInput = document.getElementById("clLabel");
      if (labelInput) labelInput.value = val || "";
    }
    function setMainTitle() {
      if (!xmlDoc) return;
      const cmdElem = xmlDoc.querySelector("Cmd");
      if (!cmdElem) return;
      const prompt = cmdElem.getAttribute("Prompt") || cmdElem.getAttribute("CmdName") || "CL Command";
      const cmdName = cmdElem.getAttribute("CmdName") || "";
      const title = `${prompt}${cmdName ? " (" + cmdName + ")" : ""} Prompt`;
      const mainTitle = document.getElementById("mainTitle");
      if (mainTitle) mainTitle.textContent = title;
    }

    function getDefaultForInput(input, parms) {
      let name = input.name;
      let kwd = name;
      let qualIdx = null;
      let qualPrompt = null;
      const qualMatch = name.match(/^(.+?)_(.+)$/);
      if (qualMatch) {
        kwd = qualMatch[1];
        qualPrompt = qualMatch[2];
      }
      const parm = Array.from(parms).find(p => p.getAttribute("Kwd") === kwd);
      if (!parm) return "";
      if (qualPrompt) {
        const quals = parm.getElementsByTagName("Qual");
        for (let q = 0; q < quals.length; q++) {
          const qual = quals[q];
          if ((qual.getAttribute("Prompt") || q.toString()) === qualPrompt || qualPrompt == q.toString()) {
            if (qual.getAttribute("Dft")) return qual.getAttribute("Dft");
            if (qual.getAttribute("Min") === "0") return "";
            return null;
          }
        }
      }
      if (name.includes("_ELEM")) {
        const elemMatch = name.match(/^(.+?)_ELEM(\d+)/);
        if (elemMatch) {
          const elemIdx = parseInt(elemMatch[2], 10);
          const elems = parm.getElementsByTagName("Elem");
          if (elems[elemIdx]) {
            if (elems[elemIdx].getAttribute("Dft")) return elems[elemIdx].getAttribute("Dft");
            if (elems[elemIdx].getAttribute("Min") === "0") return "";
            return null;
          }
        }
      }
      if (parm.getAttribute("Dft")) return parm.getAttribute("Dft");
      if (parm.getAttribute("Min") === "0") return "";
      return null;
    }

    function splitUnquotedSlash(str) {
      const result = [];
      let current = '';
      let inSingle = false, inDouble = false;
      for (let i = 0; i < str.length; i++) {
        const c = str[i];
        if (c === "'" && !inDouble) inSingle = !inSingle;
        else if (c === '"' && !inSingle) inDouble = !inDouble;
        else if (c === '/' && !inSingle && !inDouble) {
          result.push(current);
          current = '';
          continue;
        }
        current += c;
      }
      result.push(current);
      return result;
    }

    // ✅ Add this function around line 600 (after utility functions)
    function executePopulationInstructions(instructions) {
      console.log(`[clPrompter] Executing ${instructions.length} population instructions`);

      instructions.forEach((instruction, index) => {
        console.log(`[clPrompter] Instruction ${index}:`, instruction);

        // Find target element
        let target;
        if (instruction.target.startsWith('.') || instruction.target.startsWith('#')) {
          // CSS selector
          target = document.querySelector(instruction.target);
        } else {
          // Element name
          target = document.querySelector(`[name="${instruction.target}"]`) ||
            document.querySelector(`vscode-single-select[name="${instruction.target}"]`) ||
            document.querySelector(`vscode-textfield[name="${instruction.target}"]`) ||
            document.querySelector(`#${instruction.target}`);
        }

        if (!target) {
          console.log(`[clPrompter] Target not found for instruction ${index}: ${instruction.target}`);

          // ✅ Debug: List available targets
          const availableInputs = document.querySelectorAll('input, select, vscode-single-select, vscode-textfield');
          const namesList = Array.from(availableInputs)
            .map(inp => `${inp.tagName}[name="${inp.name}"][id="${inp.id}"]`)
            .slice(0, 10); // Show first 10

          console.log(`[clPrompter] Available targets (first 10):`, namesList);
          return;
        }

        // Execute instruction based on type
        switch (instruction.type) {
          case 'simple':
          case 'elem':
          case 'qual':
            setElementValue(target, instruction.value, instruction.options);
            break;

          case 'multi-instance':
            if (instruction.value === 'click') {
              console.log(`[clPrompter] Clicking: ${instruction.target}`);
              target.click();

              // Wait for DOM update after adding instance
              setTimeout(() => {
                console.log(`[clPrompter] Instance added, continuing with next instructions`);
              }, 50);
            }
            break;

          default:
            console.warn(`[clPrompter] Unknown instruction type: ${instruction.type}`);
        }
      });

      console.log('[clPrompter] Population instructions completed');
    }

    // ✅ Helper function to set element values consistently
    function setElementValue(element, value, options = {}) {
      console.log(`[clPrompter] Setting value "${value}" on ${element.tagName}[name="${element.name}"]`);

      if (element.tagName.toLowerCase() === 'vscode-single-select') {
        // Handle VS Code select
        const currentValue = element.value;
        element.value = value;

        // ✅ Enhanced VS Code Elements handling
        if (options.forceValue && element.value !== value) {
          console.log(`[clPrompter] Force-setting VS Code select value`);

          // Try creating option if it doesn't exist
          const existingOption = element.querySelector(`vscode-option[value="${value}"]`);
          if (!existingOption && value) {
            const newOption = document.createElement("vscode-option");
            newOption.value = value;
            newOption.textContent = value;
            newOption.selected = true;
            element.appendChild(newOption);
          }

          element.value = value;

          // ✅ Try shadow DOM access for combobox
          if (options.shadowDOMAccess && element.shadowRoot) {
            setTimeout(() => {
              const comboboxInput = element.shadowRoot.querySelector('.combobox-input, input, .input');
              if (comboboxInput) {
                comboboxInput.value = value;
                console.log(`[clPrompter] Set shadow DOM input: "${value}"`);
              }
            }, 10);
          }
        }

        if (options.dispatchEvents) {
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));
        }

        console.log(`[clPrompter] VS Code select value set: "${element.value}" (was: "${currentValue}")`);

      } else if (element.tagName.toLowerCase() === 'vscode-textfield') {
        // Handle VS Code textfield
        element.value = value;

        if (options.dispatchEvents) {
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));
        }

        console.log(`[clPrompter] VS Code textfield value set: "${value}"`);

      } else if (element.tagName === 'SELECT' && element.dataset.customInputId) {
        // Handle HTML select with custom input
        const customInput = document.getElementById(element.dataset.customInputId);

        // Try to find value in select options first
        let foundOption = false;
        for (let option of element.options) {
          if (option.value === value) {
            element.value = value;
            if (customInput) customInput.value = "";
            foundOption = true;
            console.log(`[clPrompter] HTML select option set: "${value}"`);
            break;
          }
        }

        // If not found in options, set custom input
        if (!foundOption && customInput && value) {
          element.selectedIndex = -1;
          customInput.value = value;
          console.log(`[clPrompter] HTML custom input set: "${value}"`);
        }

      } else {
        // Handle regular input
        element.value = value;

        if (options.dispatchEvents) {
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));
        }

        console.log(`[clPrompter] Regular input value set: "${value}"`);
      }
    }

    function createParameterInput(name, allowedVals, noCustomInput = false, defaultValue = "") {
      if (allowedVals && allowedVals.length > 0) {
        // ✅ Check for range metadata
        const rangeMetadata = allowedVals.find(v => v.startsWith('_RANGE_'));
        const hasRange = !!rangeMetadata;

        const parm = Array.from(parms).find(p => p.getAttribute("Kwd") === name);
        const effectiveLen = parm ? calculateFieldWidth(parm, allowedVals) : 25;
        const widthClass = getLengthClass(effectiveLen);

        // ✅ HYBRID APPROACH: Use dropdown for restricted, textfield with custom dropdown for flexible
        if (noCustomInput && customElements.get('vscode-single-select')) {
          // ✅ Restricted parameters - Pure dropdown (no combobox attribute)
          const select = document.createElement('vscode-single-select');
          select.name = name;
          select.id = name;
          select.className = widthClass;

          if (defaultValue) {
            select.setAttribute('data-default', defaultValue);
            select.value = defaultValue;
          }

          // Add empty option first
          const emptyOption = document.createElement('vscode-option');
          emptyOption.value = "";
          emptyOption.textContent = "";
          select.appendChild(emptyOption);

          // Add options (filter out range metadata)
          allowedVals.forEach(val => {
            if (val && val !== '_noCustomInput' && !val.startsWith('_RANGE_')) {
              const option = document.createElement('vscode-option');
              option.value = val;
              option.textContent = val;
              if (val === defaultValue) {
                option.selected = true;
              }
              select.appendChild(option);
            }
          });

          console.log(`[clPrompter] Created restricted vscode-single-select dropdown for ${name}`);
          return select;

        } else if (customElements.get('vscode-textfield')) {
          // ✅ Flexible parameters - Custom textfield with dropdown list
          const container = document.createElement('div');
          container.style.position = 'relative';
          container.style.display = 'inline-block';
          // container.style.width = '100%';

          const textfield = document.createElement('vscode-textfield');
          textfield.name = name;
          textfield.id = name;
          textfield.className = widthClass;
          // textfield.style.width = 'auto';


          if (defaultValue) {
            textfield.setAttribute('data-default', defaultValue);
            textfield.value = defaultValue;
          }

          // ✅ Add range validation attributes if range exists
          if (hasRange) {
            const rangeParts = rangeMetadata.split('_');
            if (rangeParts.length >= 4) {
              const fromValue = rangeParts[2];
              const toValue = rangeParts[3];

              // ✅ Set data attributes for your custom validation
              textfield.setAttribute('data-range-from', fromValue);
              textfield.setAttribute('data-range-to', toValue);

              // ✅ Also set HTML5 min/max to match (for native validation)
              textfield.setAttribute('min', fromValue);
              textfield.setAttribute('max', toValue);

              console.log(`[clPrompter] Set both custom and HTML5 range: ${fromValue}-${toValue}`);
            }
          }

          // ✅ Create custom dropdown list
          const suggestionsList = document.createElement('ul');
          suggestionsList.className = 'dropdown-list';
          suggestionsList.id = `${name}_suggestions`;
          suggestionsList.style.cssText = `
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: var(--vscode-dropdown-background);
        border: 1px solid var(--vscode-dropdown-border);
        border-radius: 3px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        max-height: 200px;
        overflow-y: auto;
        z-index: 1000;
        margin: 0;
        padding: 0;
        list-style: none;
        display: none;
      `;

          // Add suggestion items
          const suggestionOptions = allowedVals.filter(v => v && v !== '_noCustomInput' && !v.startsWith('_RANGE_'));
          suggestionOptions.forEach(val => {
            const listItem = document.createElement('li');
            listItem.textContent = val;
            listItem.style.cssText = `
          padding: 6px 12px;
          cursor: pointer;
          border-bottom: 1px solid var(--vscode-dropdown-border);
          color: var(--vscode-dropdown-foreground);
        `;

            // Hover effects
            listItem.addEventListener('mouseenter', () => {
              listItem.style.backgroundColor = 'var(--vscode-list-hoverBackground)';
            });
            listItem.addEventListener('mouseleave', () => {
              listItem.style.backgroundColor = '';
            });

            // Click to select
            listItem.addEventListener('click', () => {
              textfield.value = val;
              suggestionsList.style.display = 'none';
              textfield.dispatchEvent(new Event('input'));
              textfield.dispatchEvent(new Event('change'));
              textfield.focus();
            });

            suggestionsList.appendChild(listItem);
          });



          // ✅ Filter suggestions as user types + range validation
          textfield.addEventListener('input', (e) => {
            const inputValue = e.target.value.toLowerCase();
            const listItems = suggestionsList.querySelectorAll('li');

            let hasVisibleItems = false;
            listItems.forEach(item => {
              const text = item.textContent.toLowerCase();
              if (text.includes(inputValue) || inputValue === '') {
                item.style.display = 'block';
                hasVisibleItems = true;
              } else {
                item.style.display = 'none';
              }
            });

            // Show/hide dropdown based on matching items
            suggestionsList.style.display = hasVisibleItems ? 'block' : 'none';

            // ✅ Range validation with tooltip - MOVED HERE FROM WRONG LOCATION
            if (hasRange) {
              validateRangeInput(e.target);
            }
          });

          // ✅ Enhanced change event for range validation
          textfield.addEventListener('change', function (e) {
            if (hasRange) {
              validateRangeInput(e.target);
            }
          });

          // ✅ Enhanced event listeners - REMOVED SUCCESS TOOLTIPS
          textfield.addEventListener('focus', () => {
            if (suggestionOptions.length > 0) {
              suggestionsList.style.display = 'block';
            }

            // ✅ Clear any existing tooltip first, then show focus tooltip
            hideRangeTooltip();
            if (hasRange) {
              const fromValue = textfield.getAttribute('data-range-from');
              const toValue = textfield.getAttribute('data-range-to');
              // ✅ Use configurable duration
              showRangeTooltip(textfield, `💡 Enter a number between ${fromValue} and ${toValue}`, 'info');
            }
          });

          textfield.addEventListener('blur', (e) => {
            // Delay hiding to allow clicking on suggestions
            setTimeout(() => {
              suggestionsList.style.display = 'none';

              // ✅ Just hide tooltip on blur - no success tooltip
              if (!textfield.matches(':hover')) {
                hideRangeTooltip();
              }
            }, 150);
          });


          // ✅ Keyboard navigation
          textfield.addEventListener('keydown', (e) => {
            const visibleItems = Array.from(suggestionsList.querySelectorAll('li')).filter(li => li.style.display !== 'none');
            const currentSelected = suggestionsList.querySelector('li.selected');
            let selectedIndex = currentSelected ? visibleItems.indexOf(currentSelected) : -1;

            if (e.key === 'ArrowDown') {
              e.preventDefault();
              suggestionsList.style.display = 'block';
              selectedIndex = Math.min(selectedIndex + 1, visibleItems.length - 1);
              updateSelection(visibleItems, selectedIndex);
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              selectedIndex = Math.max(selectedIndex - 1, 0);
              updateSelection(visibleItems, selectedIndex);
            } else if (e.key === 'Enter') {
              if (currentSelected) {
                e.preventDefault();
                currentSelected.click();
              }
            } else if (e.key === 'Escape') {
              suggestionsList.style.display = 'none';
              hideRangeTooltip();
            }
          });

          function updateSelection(items, index) {
            items.forEach((item, i) => {
              if (i === index) {
                item.classList.add('selected');
                item.style.backgroundColor = 'var(--vscode-list-activeSelectionBackground)';
                item.style.color = 'var(--vscode-list-activeSelectionForeground)';
              } else {
                item.classList.remove('selected');
                item.style.backgroundColor = '';
                item.style.color = 'var(--vscode-dropdown-foreground)';
              }
            });
          }

          // ✅ Add enhanced placeholder hint
          if (!hasRange) {
            const optionsPreview = suggestionOptions.slice(0, 3).join(', ');
            textfield.placeholder = `e.g., ${optionsPreview}${suggestionOptions.length > 3 ? '...' : ''}`;
          }

          // ✅ Add hover support for range inputs - MOVED TO CORRECT LOCATION
          if (hasRange) {
            addRangeHoverSupport(textfield);
          }

          container.appendChild(textfield);
          container.appendChild(suggestionsList);

          console.log(`[clPrompter] Created vscode-textfield with custom dropdown (${suggestionOptions.length} options) for ${name}`);
          return container;
        }
      }

      // ✅ For parameters without predefined values, use plain vscode-textfield
      if (customElements.get('vscode-textfield')) {
        const textfield = document.createElement('vscode-textfield');
        textfield.name = name;
        textfield.id = name;

        if (defaultValue) {
          textfield.setAttribute('data-default', defaultValue);
          textfield.value = defaultValue;
        }

        console.log(`[clPrompter] Created plain vscode-textfield for ${name}`);
        return textfield;
      }

      // Final fallback to regular HTML input
      const input = document.createElement('input');
      input.type = 'text';
      input.name = name;
      input.id = name;

      if (defaultValue) {
        input.setAttribute('data-default', defaultValue);
        input.value = defaultValue;
      }

      return input;
    }



    // ✅ Enhanced hover support function - REMOVED SUCCESS TOOLTIPS
    function addRangeHoverSupport(input) {
      const fromValue = input.getAttribute('data-range-from');
      const toValue = input.getAttribute('data-range-to');

      if (!fromValue || !toValue) return;

      // ✅ Remove native title attribute to prevent dual tooltips
      input.removeAttribute('title');

      // ✅ Show hint on hover (when not focused and no tooltip exists)
      input.addEventListener('mouseenter', () => {
        // ✅ Only show hover tooltip if field is NOT focused
        if (document.activeElement !== input && !currentTooltip) {
          const value = input.value.trim();
          let message, type;

          if (!value) {
            message = `💡 Range: ${fromValue} to ${toValue}. Click to enter a value.`;
            type = 'hint';
          } else if (value.startsWith('*')) {
            message = `💡 Special value: "${value}". Range: ${fromValue}-${toValue}`;
            type = 'hint';
          } else {
            const numValue = parseInt(value, 10);
            const fromNum = parseInt(fromValue, 10);
            const toNum = parseInt(toValue, 10);

            if (!isNaN(numValue) && !isNaN(fromNum) && !isNaN(toNum)) {
              if (numValue >= fromNum && numValue <= toNum) {
                message = `✅ "${value}" is valid (range: ${fromValue}-${toValue})`;
                type = 'hint'; // ✅ Changed from 'success' to 'hint'
              } else {
                message = `❌ "${value}" is invalid (range: ${fromValue}-${toValue})`;
                type = 'error';
              }
            } else {
              message = `❓ "${value}" - Expected number in range ${fromValue}-${toValue}`;
              type = 'hint';
            }
          }

          // ✅ Use configurable hover duration
          showRangeTooltip(input, message, type, TOOLTIP_SETTINGS.hoverDuration);
        }
      });

      // ✅ Hide on mouse leave (unless focused)
      input.addEventListener('mouseleave', () => {
        if (document.activeElement !== input) {
          setTimeout(() => {
            if (document.activeElement !== input && currentTooltip) {
              hideRangeTooltip();
            }
          }, 100);
        }
      });

      // ✅ Clear tooltip immediately when user starts typing
      input.addEventListener('input', () => {
        hideRangeTooltip();
      });

      // ✅ Clear tooltip when focus leaves the input
      input.addEventListener('blur', () => {
        setTimeout(() => {
          if (document.activeElement !== input && !input.matches(':hover')) {
            hideRangeTooltip();
          }
        }, 150);
      });
    }

    // ✅ New function for showing success tooltip only on specific events
    function showSuccessTooltipIfValid(input) {
      const fromValue = input.getAttribute('data-range-from');
      const toValue = input.getAttribute('data-range-to');

      if (!fromValue || !toValue) return;

      const value = input.value.trim();

      if (value && !value.startsWith('*')) {
        const numValue = parseInt(value, 10);
        const fromNum = parseInt(fromValue, 10);
        const toNum = parseInt(toValue, 10);

        if (!isNaN(numValue) && !isNaN(fromNum) && !isNaN(toNum)) {
          if (numValue >= fromNum && numValue <= toNum) {
            showRangeTooltip(input, `✅ Valid: ${value} (range: ${fromValue}-${toValue})`, 'success', 1500);
          }
        }
      }
    }

    // ✅ Enhanced tooltip management functions
    let currentTooltip = null;
    let hideTimeout = null;

    function showRangeTooltip(input, message, type = 'info', duration = null) {
      // Clear any existing hide timeout
      if (hideTimeout) {
        clearTimeout(hideTimeout);
        hideTimeout = null;
      }

      // Remove existing tooltip
      hideRangeTooltip();

      // Create tooltip
      const tooltip = document.createElement('div');
      tooltip.className = 'range-tooltip';
      tooltip.textContent = message;

      // ✅ Enhanced type-specific styling with higher z-index
      if (type === 'error') {
        tooltip.style.background = '#d32f2f';
        tooltip.style.borderColor = '#b71c1c';
        tooltip.style.color = '#ffffff';
        tooltip.style.fontWeight = 'bold';
        tooltip.style.zIndex = TOOLTIP_SETTINGS.highZIndex;
      } else if (type === 'info') {
        tooltip.style.background = '#1976d2';
        tooltip.style.borderColor = '#1565c0';
        tooltip.style.color = '#ffffff';
        tooltip.style.zIndex = TOOLTIP_SETTINGS.highZIndex; // ✅ Higher than dropdown
      } else if (type === 'hint') {
        tooltip.style.background = '#616161';
        tooltip.style.borderColor = '#424242';
        tooltip.style.color = '#ffffff';
        tooltip.style.zIndex = TOOLTIP_SETTINGS.highZIndex;
      }

      document.body.appendChild(tooltip);

      // Position tooltip
      const rect = input.getBoundingClientRect();
      const tooltipRect = tooltip.getBoundingClientRect();

      // ✅ Better positioning logic
      let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
      let top = rect.bottom + 8;

      // Keep tooltip within viewport
      const margin = 10;
      if (left < margin) left = margin;
      if (left + tooltipRect.width > window.innerWidth - margin) {
        left = window.innerWidth - tooltipRect.width - margin;
      }

      // If tooltip would go below viewport, show above input
      if (top + tooltipRect.height > window.innerHeight - margin) {
        top = rect.top - tooltipRect.height - 8;

        // Flip arrow direction
        tooltip.classList.add('tooltip-above');
      }

      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;

      // Show tooltip with animation
      setTimeout(() => {
        tooltip.classList.add('show');
      }, 10);

      currentTooltip = tooltip;

      // ✅ Use configurable duration
      const hideDelay = duration || (
        type === 'error' ? TOOLTIP_SETTINGS.errorDuration :
          type === 'info' ? TOOLTIP_SETTINGS.focusDuration :
            TOOLTIP_SETTINGS.hoverDuration
      );

      hideTimeout = setTimeout(() => {
        hideRangeTooltip();
      }, hideDelay);
    }

    function hideRangeTooltip() {
      if (hideTimeout) {
        clearTimeout(hideTimeout);
        hideTimeout = null;
      }

      if (currentTooltip) {
        currentTooltip.classList.remove('show');
        setTimeout(() => {
          if (currentTooltip && currentTooltip.parentNode) {
            currentTooltip.parentNode.removeChild(currentTooltip);
          }
          currentTooltip = null;
        }, 200);
      }
    }



    function createDropdownWithCustomInput(name, dropdownVals, placeholder = "Or enter custom value", sngvalList = [], noCustomInput = false) {
      const container = document.createElement("span");
      const select = document.createElement("select");
      select.name = name;
      const sngvalSet = new Set(sngvalList);
      const sngvalOpts = dropdownVals.filter(val => sngvalSet.has(val));
      const otherOpts = dropdownVals.filter(val => !sngvalSet.has(val));
      const sngvalGroup = document.createElement("optgroup");
      sngvalGroup.label = "Single Values";
      sngvalOpts.forEach(val => {
        const opt = document.createElement("option");
        opt.value = val;
        opt.textContent = val;
        opt.dataset.sngval = "true";
        sngvalGroup.appendChild(opt);
      });
      select.appendChild(sngvalGroup);
      const otherGroup = document.createElement("optgroup");
      otherGroup.label = "Other Values";
      otherOpts.forEach(val => {
        const opt = document.createElement("option");
        opt.value = val;
        opt.textContent = val;
        otherGroup.appendChild(opt);
      });
      select.appendChild(otherGroup);
      if (sngvalOpts.length > 0) select.dataset.hasSngval = "true";
      if (!noCustomInput) {
        const customInput = document.createElement("input");
        customInput.type = "text";
        customInput.placeholder = placeholder;
        customInput.className = "clvar-input";
        customInput.id = name + "_custom";
        customInput.addEventListener("input", function () {
          if (customInput.value.trim() !== "") {
            select.selectedIndex = -1;
          }
        });
        select.addEventListener("change", function () {
          customInput.value = "";
        });
        select.dataset.customInputId = customInput.id;
        container.appendChild(select);
        container.appendChild(customInput);
      } else {
        container.appendChild(select);
      }
      return container;
    }

    function flattenParmValue(val) {
      if (typeof val === "string") {
        return [val];
      }
      if (Array.isArray(val)) {
        if (val.length > 0 && Array.isArray(val[0])) {
          return val.map(sub =>
            Array.isArray(sub) ? sub.join("/") : sub
          );
        }
        return val;
      }
      return [];
    }

    function splitCLQual(val) {
      let parts = [];
      let current = '';
      let inSingle = false, inDouble = false, parenDepth = 0;
      for (let i = 0; i < val.length; i++) {
        const c = val[i];
        if (c === "'" && !inDouble) inSingle = !inSingle;
        else if (c === '"' && !inSingle) inDouble = !inDouble;
        else if (c === '/' && !inSingle && !inDouble && parenDepth === 0) {
          parts.push(current);
          current = '';
          continue;
        }
        if (c === '(' && !inSingle && !inDouble) parenDepth++;
        else if (c === ')' && !inSingle && !inDouble && parenDepth > 0) parenDepth--;
        current += c;
      }
      parts.push(current);
      return parts;
    }

    function populateElemInputs(parm, kwd, vals, instanceIdx = 0, container = document) {
      console.log(`[clPrompter] ===== populateElemInputs START =====`);
      console.log(`[clPrompter] populateElemInputs: ${kwd}, vals:`, vals, `instanceIdx: ${instanceIdx}`);

      const elems = parm ? parm.getElementsByTagName("Elem") : [];
      console.log(`[clPrompter] ${kwd} - Found ${elems.length} elements`);

      // ✅ Determine if this is a multi-instance parameter
      const isMultiInstance = container !== document && container.closest('.parm-multi-group');
      console.log(`[clPrompter] ${kwd} - isMultiInstance: ${isMultiInstance}`);

      let splitVals;
      if (Array.isArray(vals)) {
        splitVals = vals;
      } else if (typeof vals === 'string') {
        if (isCLExpression(vals)) {
          splitVals = [vals];
        } else {
          splitVals = vals.split(' ');
        }
      } else {
        splitVals = [];
      }

      console.log(`[clPrompter] ${kwd} - Split values:`, splitVals);

      for (let e = 0; e < elems.length; e++) {
        const elem = elems[e];
        const elemType = elem.getAttribute("Type") || "CHAR";

        // ✅ Use correct naming pattern based on instance type
        const elemName = isMultiInstance ? `${kwd}_ELEM${e}_${instanceIdx}` : `${kwd}_ELEM${e}`;
        const value = splitVals[e] !== undefined ? splitVals[e] : "";

        console.log(`[clPrompter] ${kwd} - Processing element ${e}:`);
        console.log(`[clPrompter]   - elemName: ${elemName}`);
        console.log(`[clPrompter]   - elemType: ${elemType}`);
        console.log(`[clPrompter]   - value: "${value}"`);

        // ✅ Handle nested ELEM (ELEM within ELEM) - like TOPGMQ's "Call stack entry identifier"
        if (elemType === "ELEM") {
          console.log(`[clPrompter] ${kwd} - Found nested ELEM: ${elemName}`);

          // ✅ Parse the nested value - strip parentheses and split on spaces
          let subValues = [];
          if (typeof value === 'string' && value.trim() !== '') {
            let cleanValue = value.trim();

            // ✅ Remove surrounding parentheses if present
            if (cleanValue.startsWith('(') && cleanValue.endsWith(')')) {
              cleanValue = cleanValue.slice(1, -1); // Remove first and last character
              console.log(`[clPrompter] ${kwd} - Stripped parentheses: "${value}" -> "${cleanValue}"`);
            }

            subValues = cleanValue.split(' ').filter(v => v.trim() !== '');
          } else if (Array.isArray(value)) {
            subValues = value;
          }

          console.log(`[clPrompter] ${kwd} - Nested ELEM sub-values:`, subValues);

          // Get the sub-elements
          const subElems = elem.querySelectorAll(":scope > Elem");
          console.log(`[clPrompter] ${kwd} - Found ${subElems.length} sub-elements`);

          // Populate each sub-element
          for (let se = 0; se < subElems.length; se++) {
            const subElemName = `${elemName}_SUB${se}`;
            const subValue = subValues[se] !== undefined ? subValues[se] : "";

            console.log(`[clPrompter] ${kwd} - Processing sub-element ${se}:`);
            console.log(`[clPrompter]   - subElemName: ${subElemName}`);
            console.log(`[clPrompter]   - subValue: "${subValue}"`);

            // Find the sub-element input
            let subInput = container.querySelector(`[name="${subElemName}"]`);

            if (!subInput) {
              // Try VS Code Elements
              const vsCodeSelect = container.querySelector(`vscode-single-select[name="${subElemName}"]`);
              const vsCodeTextfield = container.querySelector(`vscode-textfield[name="${subElemName}"]`);
              subInput = vsCodeSelect || vsCodeTextfield;
            }

            if (subInput) {
              if (subInput.tagName.toLowerCase() === 'vscode-single-select') {
                // Handle VS Code select
                subInput.value = subValue;
                console.log(`[clPrompter]   - Set VS Code select: "${subValue}" for sub-element ${se}`);
              } else {
                // Handle regular input
                subInput.value = subValue;
                console.log(`[clPrompter]   - Set regular input: "${subValue}" for sub-element ${se} (${subInput.tagName})`);
              }
            } else {
              console.log(`[clPrompter]   - NO SUB-INPUT FOUND for ${subElemName}`);

              // ✅ Debug: List all available inputs in container
              const allInputs = container.querySelectorAll('input, select, vscode-single-select, vscode-textfield');
              console.log(`[clPrompter]   - Available inputs in container:`,
                Array.from(allInputs).map(inp => `${inp.tagName}[name="${inp.name}"][id="${inp.id}"]`)
              );
            }
          }
        } else {
          // ✅ Regular element processing (existing logic)
          let input = container.querySelector(`[name="${elemName}"]`);

          if (!input) {
            // Try VS Code Elements
            const vsCodeSelect = container.querySelector(`vscode-single-select[name="${elemName}"]`);
            const vsCodeTextfield = container.querySelector(`vscode-textfield[name="${elemName}"]`);
            input = vsCodeSelect || vsCodeTextfield;
          }

          if (!input) {
            // Try select+custom pattern
            const select = container.querySelector(`select[name="${elemName}"]`);
            const customInput = container.querySelector(`#${elemName}_custom`);

            if (select && customInput) {
              // Handle select+custom logic
              let foundIdx = -1;
              for (let i = 0; i < select.options.length; i++) {
                if (select.options[i].value.trim().toUpperCase() === value.trim().toUpperCase()) {
                  foundIdx = i;
                  break;
                }
              }
              if (foundIdx !== -1 && value) {
                select.selectedIndex = foundIdx;
                customInput.value = "";
                console.log(`[clPrompter]   - Set select option ${foundIdx} for element ${e}`);
              } else if (value) {
                select.selectedIndex = -1;
                customInput.value = value;
                console.log(`[clPrompter]   - Set custom input "${value}" for element ${e}`);
              }
              continue;
            }
          }

          if (input) {
            if (input.tagName.toLowerCase() === 'vscode-single-select') {
              // Handle VS Code select
              input.value = value;
              console.log(`[clPrompter]   - Set VS Code select: "${value}" for element ${e}`);
            } else {
              // Handle regular input
              input.value = value;
              console.log(`[clPrompter]   - Set regular input: "${value}" for element ${e} (${input.tagName})`);
            }
          } else {
            console.log(`[clPrompter]   - NO INPUT FOUND for element ${e} (tried ${elemName})`);
          }
        }
      }

      console.log(`[clPrompter] ===== populateElemInputs END =====`);
    }

    function populateQualInputs(parm, kwd, vals, container = document) {
      const quals = parm ? parm.getElementsByTagName("Qual") : [];
      let parts;
      if (Array.isArray(vals)) {
        parts = vals;
      } else if (typeof vals === "string") {
        parts = splitCLQual(vals);
      } else {
        parts = [];
      }

      console.log(`[clPrompter] populateQualInputs: ${kwd}, parts:`, parts);
      console.log(`[clPrompter] ===== populateQualInputs DEBUG =====`);
      console.log(`[clPrompter] ${kwd} - Input vals:`, vals);
      console.log(`[clPrompter] ${kwd} - Split parts:`, parts);
      console.log(`[clPrompter] ${kwd} - Parts length:`, parts.length);
      console.log(`[clPrompter] ${kwd} - Quals length:`, quals.length);

      for (let q = 0; q < quals.length; q++) {
        const qName = `${kwd}_QUAL${q}`;
        // ✅ RESTORE reverse indexing - QUAL0 gets parts[length-1-0], QUAL1 gets parts[length-1-1]
        const reverseIndex = parts.length - 1 - q;
        const value = parts[reverseIndex] !== undefined ? parts[reverseIndex] : "";

        console.log(`[clPrompter] ${kwd} - QUAL${q}:`);
        console.log(`[clPrompter]   - qName: ${qName}`);
        console.log(`[clPrompter]   - reverseIndex: ${reverseIndex} (${parts.length}-1-${q})`);
        console.log(`[clPrompter]   - value: "${value}"`);
        console.log(`[clPrompter]   - parts[${reverseIndex}]: "${parts[reverseIndex]}"`);

        const vsCodeSelect = container.querySelector(`vscode-single-select[name="${qName}"]`);
        const select = container.querySelector(`select[name="${qName}"]`);
        const customInput = container.querySelector(`#${qName}_custom`);

        console.log(`[clPrompter]   - Found vsCodeSelect: ${!!vsCodeSelect}`);
        console.log(`[clPrompter]   - Found select: ${!!select}`);
        console.log(`[clPrompter]   - Found customInput: ${!!customInput}`);

        // ✅ Handle VS Code Elements combobox first
        if (vsCodeSelect) {
          console.log(`[clPrompter]   - Processing VS Code select for ${qName}`);
          console.log(`[clPrompter]   - Value to set: "${value}"`);
          console.log(`[clPrompter]   - Current vsCodeSelect.value before: "${vsCodeSelect.value}"`);

          // Check if value exists in options first
          const options = vsCodeSelect.querySelectorAll('vscode-option');
          console.log(`[clPrompter]   - Found ${options.length} options`);

          let foundOption = false;
          for (let option of options) {
            console.log(`[clPrompter]   - Checking option: "${option.value}"`);
            if (option.value === value) {
              vsCodeSelect.value = value;
              foundOption = true;
              console.log(`[clPrompter]   - Set VS Code select option: "${value}"`);
              break;
            }
          }

          // ✅ If not found in options, set custom value REGARDLESS of combobox attribute
          if (!foundOption && value) {
            console.log(`[clPrompter]   - Setting custom value: "${value}"`);

            // ✅ Force set the value first
            vsCodeSelect.value = value;

            // ✅ Create a temporary option if needed (some VS Code Elements require this)
            const tempOption = document.createElement("vscode-option");
            tempOption.value = value;
            tempOption.textContent = value;
            tempOption.selected = true;
            vsCodeSelect.appendChild(tempOption);

            // ✅ Set value again after adding option
            vsCodeSelect.value = value;

            // ✅ Enhanced shadow DOM access
            const trySetShadowDOM = () => {
              if (vsCodeSelect.shadowRoot) {
                const comboboxInput = vsCodeSelect.shadowRoot.querySelector('.combobox-input, input, .input');
                if (comboboxInput) {
                  comboboxInput.value = value;
                  console.log(`[clPrompter]   - Set VS Code shadow DOM input: "${value}"`);
                  return true;
                }
              }
              return false;
            };

            // ✅ Try immediately and with delays
            if (!trySetShadowDOM()) {
              setTimeout(trySetShadowDOM, 10);
              setTimeout(trySetShadowDOM, 50);
              setTimeout(trySetShadowDOM, 100);
            }

            // ✅ Dispatch events to ensure updates
            vsCodeSelect.dispatchEvent(new Event('input', { bubbles: true }));
            vsCodeSelect.dispatchEvent(new Event('change', { bubbles: true }));
            vsCodeSelect.requestUpdate?.();

            console.log(`[clPrompter]   - Set VS Code select custom value: "${value}"`);
          }

          // ✅ Final verification with delay
          setTimeout(() => {
            console.log(`[clPrompter]   - Final verification - ${qName}.value: "${vsCodeSelect.value}"`);

            // ✅ Additional fallback: if value still doesn't match, force it
            if (vsCodeSelect.value !== value && value) {
              console.log(`[clPrompter]   - Value mismatch detected, forcing value`);
              vsCodeSelect.setAttribute('value', value);

              // Try to set internal property directly
              if (vsCodeSelect._value !== undefined) {
                vsCodeSelect._value = value;
              }
            }
          }, 150);
        } else if (select && customInput) {
          let foundIdx = -1;
          for (let i = 0; i < select.options.length; i++) {
            if (select.options[i].value.trim().toUpperCase() === value.trim().toUpperCase()) {
              foundIdx = i;
              break;
            }
          }
          if (foundIdx !== -1 && value) {
            select.selectedIndex = foundIdx;
            customInput.value = "";
            console.log(`[clPrompter]   - Set HTML select option: "${value}"`);
          } else if (value) {
            select.selectedIndex = -1;
            customInput.value = value;
            console.log(`[clPrompter]   - Set HTML custom input: "${value}"`);
          }
        } else {
          const input = container.querySelector(`[name="${qName}"]`);
          if (input) {
            input.value = value;
            console.log(`[clPrompter]   - Set regular input: "${value}"`);
          } else {
            console.log(`[clPrompter]   - NO INPUT FOUND for ${qName}`);
          }
        }
      }
      console.log(`[clPrompter] ===== END populateQualInputs DEBUG =====`);
    }

    // ✅ Valid IBM i CL parameter data types
    const CL_DATA_TYPES = [
      'DEC',
      'LGL',
      'CHAR',
      'INT2',
      'INT4',
      'UINT2',
      'UINT4',
      'NAME',
      'GENERIC',
      'VARNAME',
      'DATE',
      'TIME',
      'CMD',
      'X',
      'ZEROELEM',
      'NULL',
      'CMDSTR',
      'PNAME',
      'SNAME',
      'CNAME'
    ];

    // ✅ Container/structure types (not actual data types)
    const CL_CONTAINER_TYPES = [
      'ELEM',
      'QUAL'
    ];

    // ✅ Check if a type is a valid data type
    function isValidDataType(type) {
      return CL_DATA_TYPES.includes((type || '').toUpperCase());
    }

    // ✅ Check if a type is a container type
    function isContainerType(type) {
      return CL_CONTAINER_TYPES.includes((type || '').toUpperCase());
    }

    // ✅ Check if a type needs special handling
    function getTypeCategory(type) {
      const upperType = (type || '').toUpperCase();

      if (CL_DATA_TYPES.includes(upperType)) {
        return 'DATA_TYPE';
      } else if (CL_CONTAINER_TYPES.includes(upperType)) {
        return 'CONTAINER';
      } else {
        return 'UNKNOWN';
      }
    }

    function calculateFieldWidth(parm, allowedVals) {
      const type = (parm.getAttribute('Type') || 'CHAR').toUpperCase();
      const lenAttr = parm.getAttribute('Len') || '';
      const kwd = parm.getAttribute('Kwd') || 'UNKNOWN';
      const isRestricted = parm.getAttribute('Rstd') === 'YES';

      if (isContainerType(type)) {
        console.log(`[calculateFieldWidth] ${kwd}: Container type ${type}, using default length`);
        return 40;
      }

      let effectiveLen = 10;

      // Handle type-specific base lengths
      switch (type) {
        case 'INT2':
          effectiveLen = 6;
          break;
        case 'INT4':
          effectiveLen = 11;
          break;
        case 'UINT2':
          effectiveLen = 5;
          break;
        case 'UINT4':
          effectiveLen = 10;
          break;
        case 'VARNAME':
          effectiveLen = parseInt(lenAttr, 10) || 11;
          break;
        case 'NAME':
        case 'PNAME':
        case 'SNAME':
        case 'CNAME':
          effectiveLen = parseInt(lenAttr, 10) || 10;
          break;
        case 'DATE':
          effectiveLen = 10;
          break;
        case 'TIME':
          effectiveLen = 8;
          break;
        case 'LGL':
          effectiveLen = 1;
          break;
        case 'DEC':
          if (lenAttr.includes('.')) {
            const [totalDigits] = lenAttr.split('.').map(s => parseInt(s, 10));
            effectiveLen = totalDigits + 1;
          } else {
            effectiveLen = parseInt(lenAttr, 10) || 10;
          }
          break;
        case 'X':
          if (lenAttr.includes('.')) {
            const parts = lenAttr.split('.');
            if (parts.length >= 3) {
              const charLen = parseInt(parts[0], 10) || 10;
              const numDigits = parseInt(parts[1], 10) || 10;
              const numDecimals = parseInt(parts[2], 10) || 0;
              const numDisplayLen = numDigits + 1;
              effectiveLen = Math.max(charLen, numDisplayLen);

              console.log(`[calculateFieldWidth] ${kwd}: Type X - CharLen=${charLen}, NumFormat=${numDigits}.${numDecimals}, DisplayLen=${numDisplayLen}, Using=${effectiveLen}`);
            } else if (parts.length === 2) {
              const charLen = parseInt(parts[0], 10) || 10;
              const numLen = parseInt(parts[1], 10) || 10;
              effectiveLen = Math.max(charLen, numLen);

              console.log(`[calculateFieldWidth] ${kwd}: Type X - CharLen=${charLen}, NumLen=${numLen}, Using=${effectiveLen}`);
            } else {
              effectiveLen = parseInt(parts[0], 10) || 10;
            }
          } else {
            effectiveLen = parseInt(lenAttr, 10) || 10;
          }
          break;
        case 'GENERIC':
          effectiveLen = parseInt(lenAttr, 10) || 10;
          break;
        case 'NULL':
        case 'ZEROELEM':
          effectiveLen = 0;
          break;
        case 'CMD':
        case 'CMDSTR':
          effectiveLen = parseInt(lenAttr, 10) || 2000;
          break;
        case 'CHAR':
        default:
          effectiveLen = parseInt(lenAttr, 10) || 25;
          break;
      }

      // ✅ NEW: Find the longest SPCVAL/SNGVAL value
      let maxSpcValLen = 0;
      if (Array.isArray(allowedVals)) {
        allowedVals.forEach(val => {
          if (val && val !== '_noCustomInput' && !val.startsWith('_RANGE_')) {
            maxSpcValLen = Math.max(maxSpcValLen, val.length);
          }
        });
      }

      // ✅ NEW: For restricted fields, also check SpcVal/SngVal directly from XML
      const spcVals = parm.querySelectorAll('SpcVal Value, SngVal Value');
      spcVals.forEach(valElem => {
        const val = valElem.getAttribute('Val');
        if (val && val !== '*NULL') {
          maxSpcValLen = Math.max(maxSpcValLen, val.length);
        }
      });

      // ✅ NEW: If this is a restricted field, prioritize SpcVal lengths over declared length
      let finalLen;
      if (isRestricted && maxSpcValLen > 0) {
        finalLen = Math.max(effectiveLen, maxSpcValLen);
        console.log(`[calculateFieldWidth] ${kwd}: Restricted field - DeclaredLen=${effectiveLen}, MaxSpcValLen=${maxSpcValLen}, Using=${finalLen}`);
      } else {
        finalLen = Math.max(effectiveLen, maxSpcValLen);
      }

      console.log(`[calculateFieldWidth] ${kwd}: Type=${type}, Len=${lenAttr}, Rstd=${isRestricted}, Calculated=${effectiveLen}, MaxSpcVal=${maxSpcValLen}, Final=${finalLen}`);

      return finalLen;
    }

    // ✅ Get CSS width class based on effective length
    function getLengthClass(effectiveLen) {
      if (effectiveLen <= 6) return 'input-xs';      // 80px - small numbers, short codes
      if (effectiveLen <= 12) return 'input-sm';     // 120px - medium numbers, names
      if (effectiveLen <= 25) return 'input-md';     // 200px - longer names, paths
      if (effectiveLen <= 50) return 'input-lg';     // 300px - descriptions, titles
      if (effectiveLen <= 80) return 'input-xl';     // 400px - long text
      return 'input-full';                           // 100% - very long text (textarea)
    }

    function populateFormFromValues_ORIGINAL(paramMap) {
      console.log("[clPrompter] populateFormFromValues called with:", paramMap);
      console.log("[clPrompter] Keys to process:", Object.keys(paramMap));
      for (const [kwd, vals] of Object.entries(paramMap)) {
        console.log(`[clPrompter] Processing parameter: ${kwd}, values:`, vals); // ✅ Add this line
        const group = document.querySelector(`.parm-multi-group[data-kwd="${kwd}"]`);
        if (group) {
          console.log(`[clPrompter] ${kwd} - Found multi-group, skipping ELEM check`); // ✅ Add this
          let instances = group.querySelectorAll('.parm-instance');
          for (let i = 1; i < instances.length; i++) instances[i].remove();
          let splitValsArr = flattenParmValue(vals);
          for (let i = 0; i < splitValsArr.length; i++) {
            if (i > 0) {
              const addBtn = group.querySelector('.add-parm-btn');
              if (addBtn) addBtn.click();
            }
            const inst = group.querySelectorAll('.parm-instance')[i];
            if (!inst) continue;
            const parm = Array.from(parms).find(p => p.getAttribute("Kwd") === kwd);
            if (parm && parm.getElementsByTagName("Elem").length > 0) {
              console.log(`[clPrompter] ${kwd} - Processing ELEM parameter, values:`, vals);
              populateElemInputs(parm, kwd, splitValsArr[i], i, inst);
              continue;
            }
            if (parm && parm.getElementsByTagName("Qual").length > 0) {
              populateQualInputs(parm, kwd, splitValsArr[i], inst);
              continue;
            }
            console.log(`[clPrompter] ${kwd} - Processing as simple parameter`); // ✅ Add this

            const select = inst.querySelector(`select[name="${kwd}"]`);
            const customInput = inst.querySelector(`#${kwd}_custom`);
            let value = (splitValsArr[i] !== undefined && splitValsArr[i] !== null && splitValsArr[i] !== "")
              ? splitValsArr[i].toString().trim()
              : getDefaultForInput(select, parms);
            if (select && customInput) {
              let foundIdx = -1;
              for (let j = 0; j < select.options.length; j++) {
                if (select.options[j].value.trim().toUpperCase() === (value || "").trim().toUpperCase()) {
                  foundIdx = j;
                  break;
                }
              }
              if (foundIdx !== -1 && value) {
                select.selectedIndex = foundIdx;
                customInput.value = "";
              } else if (value) {
                select.selectedIndex = -1;
                customInput.value = value;
              } else {
                select.selectedIndex = -1;
                customInput.value = "";
              }
            } else {
              const input = inst.querySelector(`[name="${kwd}"]`);
              if (input) input.value = value;
            }
          }
          handleSngvalLocking(group);
          continue;
        }
        const parm = Array.from(parms).find(p => p.getAttribute("Kwd") === kwd);
        if (parm && parm.getElementsByTagName("Elem").length > 0) {
          populateElemInputs(parm, kwd, vals, 0, document);
          continue;
        }
        if (parm && parm.getElementsByTagName("Qual").length > 0) {
          populateQualInputs(parm, kwd, vals, document);
          continue;
        }
        // --- Simple parameter ---
        const input = document.querySelector(`[name="${kwd}"], [name^="${kwd}_"]`);
        if (input) {
          input.value = Array.isArray(vals) ? vals[0] : vals;
        }
      }
      document.querySelectorAll('.elem-group').forEach(group => handleSngvalLocking(group));
    }

    function setupSngValLockingForFirstElem(container, firstElemSelectId, kwd) {
      const firstElemSelect = container.querySelector(`#${firstElemSelectId}`);
      if (!firstElemSelect) return;

      function updateElemLocking() {
        const selectedOption = firstElemSelect.selectedOptions[0];
        const isSngVal = selectedOption && selectedOption.getAttribute("data-sngval") === "true";

        // Find all OTHER ELEM inputs in this container (not the first one)
        const otherElemInputs = container.querySelectorAll(`[name^="${kwd}_ELEM"]:not([name="${firstElemSelectId}"])`);

        if (isSngVal) {
          // SngVal selected - disable and clear all OTHER ELEM inputs
          otherElemInputs.forEach(input => {
            input.disabled = true;
            input.value = "";

            const parent = input.closest('.form-div');
            if (parent) {
              parent.style.opacity = '0.5';
              parent.title = 'Disabled because single value is selected above';
            }
          });
        } else {
          // No SngVal selected - enable all OTHER ELEM inputs
          otherElemInputs.forEach(input => {
            input.disabled = false;

            const parent = input.closest('.form-div');
            if (parent) {
              parent.style.opacity = '1';
              parent.title = '';
            }
          });
        }
      }

      // Listen for changes
      firstElemSelect.addEventListener('change', updateElemLocking);

      // Initial setup
      updateElemLocking();
    }



    function handleSngvalLocking(container) {
      const sngvalSelects = container.querySelectorAll('select[data-has-sngval="true"]');
      sngvalSelects.forEach(select => {
        function updateLocking() {
          const isSngval =
            select.value &&
            select.selectedIndex !== -1 &&
            select.options[select.selectedIndex].dataset.sngval === "true";

          const allInputs = Array.from(container.querySelectorAll('input, select')).filter(i => {
            if (i === select) return false;
            if (i.id && select.dataset.customInputId && i.id === select.dataset.customInputId) return false;
            return true;
          });

          if (isSngval) {
            allInputs.forEach(i => {
              i.disabled = true;
              if (i.tagName === "SELECT") i.selectedIndex = -1;
              else i.value = "";
            });
          } else {
            allInputs.forEach(i => i.disabled = false);
          }

          const multiGroup = container.closest('.parm-multi-group');
          if (multiGroup) {
            const addBtn = multiGroup.querySelector('.add-parm-btn');
            if (addBtn) addBtn.disabled = isSngval;
            if (isSngval) {
              multiGroup.querySelectorAll('.parm-instance').forEach(inst => {
                if (inst !== container) inst.style.display = "none";
              });
            } else {
              multiGroup.querySelectorAll('.parm-instance').forEach(inst => {
                inst.style.display = "";
              });
            }
          }
        }

        select.addEventListener('change', function () {
          if (select.dataset.customInputId) {
            const customInput = document.getElementById(select.dataset.customInputId);
            if (customInput) customInput.value = "";
          }
          updateLocking();
        });

        updateLocking();
      });
    }

    function createInputForType(type, name, value, len) {
      console.log(`[clPrompter] createInputForType called: type=${type}, name=${name}, value=${value}, len=${len}`);

      try {
        const upperType = (type || 'CHAR').toUpperCase().replace('*', '');
        const typeCategory = getTypeCategory(upperType);

        if (typeCategory === 'CONTAINER') {
          console.error(`[clPrompter] Container type ${upperType} should not reach createInputForType`);
          return null;
        }

        if (typeCategory === 'UNKNOWN') {
          console.warn(`[clPrompter] Unknown type ${upperType}, treating as CHAR`);
        }

        // ✅ Replace lines 2033-2034 with this simpler fix:
        let parm = Array.from(parms).find(p => p.getAttribute("Kwd") === name);

        // ✅ For ELEM inputs, find the parent parameter
        if (!parm && name.includes('_ELEM')) {
          const parentKwd = name.split('_ELEM')[0];
          parm = Array.from(parms).find(p => p.getAttribute("Kwd") === parentKwd);
        }

        const effectiveLen = parm ? calculateFieldWidth(parm, []) : (parseInt(len, 10) || 25);

        const widthClass = getLengthClass(effectiveLen);

        let input;
        const useVSCodeElements = customElements.get('vscode-textfield') &&
          customElements.get('vscode-textarea');

        console.log(`[clPrompter] ${name} - Type: ${upperType}, EffectiveLen: ${effectiveLen}, WidthClass: ${widthClass}`);

        // ✅ First, handle all type-specific logic (no textarea creation here)
        switch (upperType) {
          case 'DEC':
          case 'INT2':
          case 'INT4':
          case 'UINT2':
          case 'UINT4':
            console.log(`[clPrompter] Processing number type: ${upperType}`);

            if (useVSCodeElements) {
              input = document.createElement('vscode-textfield');
              input.className = widthClass;
              input.setAttribute('type', 'number');

              const hasXMLRange = parm && (
                parm.getAttribute('RangeMinVal') ||
                parm.getAttribute('RangeMaxVal')
              );

              if (hasXMLRange) {
                const minVal = parm.getAttribute('RangeMinVal');
                const maxVal = parm.getAttribute('RangeMaxVal');

                if (minVal) input.setAttribute('min', minVal);
                if (maxVal) input.setAttribute('max', maxVal);

                console.log(`[clPrompter] ${name} - Using XML range: ${minVal} to ${maxVal}`);
              } else {
                if (upperType === 'INT2') {
                  input.setAttribute('min', '-32768');
                  input.setAttribute('max', '32767');
                } else if (upperType === 'INT4') {
                  input.setAttribute('min', '-2147483648');
                  input.setAttribute('max', '2147483647');
                } else if (upperType === 'UINT2') {
                  input.setAttribute('min', '0');
                  input.setAttribute('max', '65535');
                } else if (upperType === 'UINT4') {
                  input.setAttribute('min', '0');
                  input.setAttribute('max', '4294967295');
                }

                console.log(`[clPrompter] ${name} - Using type constraints for ${upperType}`);
              }

              if (upperType === 'DEC' && len && len.includes('.')) {
                const [, decimalPlaces] = len.split('.');
                const step = parseFloat(`0.${'0'.repeat(parseInt(decimalPlaces) - 1)}1`);
                input.setAttribute('step', step.toString());
              }
            } else {
              input = document.createElement("input");
              input.type = "number";
              input.className = widthClass;
            }
            break;

          case 'VARNAME':
            console.log(`[clPrompter] Processing VARNAME type: ${upperType}`);
            if (useVSCodeElements) {
              input = document.createElement('vscode-textfield');
              input.className = widthClass;
              input.setAttribute('pattern', '&[A-Z][A-Z0-9]*');
              input.placeholder = '&VARIABLENAME';
              input.title = 'CL variable name (must start with &)';
            } else {
              input = document.createElement("input");
              input.type = "text";
              input.className = widthClass;
              input.pattern = "&[A-Z][A-Z0-9]*";
              input.placeholder = "&VARIABLENAME";
            }
            break;

          case 'NAME':
          case 'PNAME':
          case 'SNAME':
          case 'CNAME':
          case 'GENERIC':
            console.log(`[clPrompter] Processing name type: ${upperType}`);
            if (useVSCodeElements) {
              input = document.createElement('vscode-textfield');
              input.className = widthClass;
              input.placeholder = 'Name';
            } else {
              input = document.createElement("input");
              input.type = "text";
              input.className = widthClass;
            }
            break;

          case 'DATE':
            console.log(`[clPrompter] Processing date type: ${upperType}`);
            if (useVSCodeElements) {
              input = document.createElement('vscode-textfield');
              input.setAttribute('type', 'date');
              input.className = 'input-md';
            } else {
              input = document.createElement("input");
              input.type = "date";
              input.className = 'input-md';
            }
            break;

          case 'TIME':
            console.log(`[clPrompter] Processing time type: ${upperType}`);
            if (useVSCodeElements) {
              input = document.createElement('vscode-textfield');
              input.setAttribute('type', 'time');
              input.className = 'input-sm';
            } else {
              input = document.createElement("input");
              input.type = "time";
              input.className = 'input-sm';
            }
            break;

          case 'LGL':
            console.log(`[clPrompter] Processing logical type: ${upperType}`);
            if (useVSCodeElements) {
              input = document.createElement('vscode-single-select');
              input.className = 'input-xs';

              const opt0 = document.createElement('vscode-option');
              opt0.value = '0';
              opt0.textContent = '0 (False)';

              const opt1 = document.createElement('vscode-option');
              opt1.value = '1';
              opt1.textContent = '1 (True)';

              input.appendChild(opt0);
              input.appendChild(opt1);
            } else {
              input = document.createElement("input");
              input.type = "text";
              input.className = 'input-xs';
              input.placeholder = "0 or 1";
            }
            break;

          case 'X':
            console.log(`[clPrompter] Processing any-type (X) parameter: ${upperType}`);

            let charLen = 25, numDigits = 10, numDecimals = 0;
            if (len && len.includes('.')) {
              const parts = len.split('.');
              if (parts.length >= 3) {
                charLen = parseInt(parts[0], 10) || 25;
                numDigits = parseInt(parts[1], 10) || 10;
                numDecimals = parseInt(parts[2], 10) || 0;
              } else if (parts.length === 2) {
                charLen = parseInt(parts[0], 10) || 25;
                numDigits = parseInt(parts[1], 10) || 10;
              }
            } else if (len) {
              charLen = parseInt(len, 10) || 25;
            }

            if (useVSCodeElements) {
              input = document.createElement('vscode-textfield');
              input.className = widthClass;
              input.placeholder = `Text (max ${charLen}) or Number (${numDigits}.${numDecimals})`;
              input.title = `Accepts character data (max ${charLen} chars) or numeric data (${numDigits} digits, ${numDecimals} decimals)`;
            } else {
              input = document.createElement("input");
              input.type = "text";
              input.className = widthClass;
              input.placeholder = `Text or Number`;
            }

            input.setAttribute('maxlength', charLen.toString());
            break;

          case 'NULL':
          case 'ZEROELEM':
            console.log(`[clPrompter] Processing hidden type: ${upperType}`);
            input = document.createElement("input");
            input.type = "hidden";
            break;

          default:
            console.log(`[clPrompter] Processing default/CHAR type: ${upperType}`);
            if (useVSCodeElements) {
              input = document.createElement('vscode-textfield');
              input.className = widthClass;
            } else {
              input = document.createElement("input");
              input.type = "text";
              input.className = widthClass;
            }
            break;
        }

        // ✅ AFTER type processing: Convert to textarea if length exceeds threshold
        let actualLen = effectiveLen; // Start with calculated width

        // Override with declared length if it's larger and makes sense
        let declaredLen = parseInt(len, 10);
        if (!isNaN(declaredLen) && declaredLen > 0) {
          actualLen = Math.max(actualLen, declaredLen);
        }

        if (actualLen > 80 && upperType !== 'NULL' && upperType !== 'ZEROELEM' && upperType !== 'LGL') {
          console.log(`[clPrompter] Converting to textarea due to length: ${actualLen} > 80 for ${name}`);
          if (useVSCodeElements && customElements.get('vscode-textarea')) {
            const textarea = document.createElement('vscode-textarea');
            textarea.className = 'input-full';
            textarea.style.minHeight = '60px';
            textarea.rows = Math.min(Math.ceil(actualLen / 80), 5);

            // Copy over any attributes from the original input
            textarea.name = input.name;
            textarea.id = input.id;
            if (input.placeholder) textarea.placeholder = input.placeholder;
            if (input.title) textarea.title = input.title;

            input = textarea;
          } else {
            const textarea = document.createElement("textarea");
            textarea.className = 'input-full';
            textarea.style.minHeight = '60px';
            textarea.rows = Math.min(Math.ceil(actualLen / 80), 5);

            // Copy over any attributes from the original input
            textarea.name = input.name;
            textarea.id = input.id;
            if (input.placeholder) textarea.placeholder = input.placeholder;
            if (input.title) textarea.title = input.title;

            input = textarea;
          }
        }

        // ✅ Set common attributes
        input.name = name;
        input.id = name;

        if (value) {
          input.value = value;
          input.setAttribute('data-default', value);
          console.log(`[clPrompter] Set value for ${name}: ${value}`);
        }

        if (declaredLen && input.tagName !== 'SELECT') {
          if (input.tagName.toLowerCase() === 'vscode-textfield' ||
            input.tagName.toLowerCase() === 'vscode-textarea' ||
            input.tagName === 'INPUT' ||
            input.tagName === 'TEXTAREA') {
            input.setAttribute("maxlength", declaredLen);
            console.log(`[clPrompter] Set maxlength for ${name}: ${declaredLen}`);
          }
        }

        // ✅ Add VARNAME validation
        if (input.getAttribute('pattern') === '&[A-Z][A-Z0-9]*') {
          input.addEventListener('input', function (e) {
            const value = e.target.value.toUpperCase();
            if (value && !value.startsWith('&')) {
              e.target.value = '&' + value;
            }
            e.target.value = e.target.value.toUpperCase();
          });

          input.addEventListener('blur', function (e) {
            const value = e.target.value;
            if (value && !value.match(/^&[A-Z][A-Z0-9]*$/)) {
              e.target.style.borderColor = 'var(--vscode-inputValidation-errorBorder)';
              e.target.title = 'Invalid CL variable name. Must be &VARIABLENAME format.';
            } else {
              e.target.style.borderColor = '';
              e.target.title = 'CL variable name (must start with &)';
            }
          });
        }

        console.log(`[clPrompter] Successfully created ${input.tagName.toLowerCase()} for ${name}, class=${input.className}`);
        return input;

      } catch (error) {
        console.error(`[clPrompter] Error in createInputForType for ${name}:`, error);

        const fallbackInput = document.createElement("input");
        fallbackInput.type = "text";
        fallbackInput.name = name;
        fallbackInput.id = name;
        fallbackInput.className = 'input-md';

        if (value) {
          fallbackInput.value = value;
          fallbackInput.setAttribute('data-default', value);
        }

        return fallbackInput;
      }
    }

    function isValidName(val) {
      const trimmed = val.trim();
      if (trimmed.startsWith("&")) {
        return /^[&][A-Z$#@][A-Z0-9$#@_.]{0,10}$/i.test(trimmed);
      }
      if (
        (trimmed.startsWith("'") && trimmed.endsWith("'")) ||
        (trimmed.startsWith('"') && trimmed.endsWith('"'))
      ) {
        return true;
      }
      return /^[A-Z$#@][A-Z0-9$#@_.]{0,10}$/i.test(trimmed);
    }

    function setupSngValLocking(container, sngValSelectId, kwd) {
      const sngValSelect = container.querySelector(`#${sngValSelectId}`);
      if (!sngValSelect) return;

      function updateSngValLocking() {
        const selectedOption = sngValSelect.selectedOptions[0];
        const isSngVal = selectedOption && selectedOption.getAttribute("data-sngval") === "true";

        // Find all ELEM inputs in this container
        const elemInputs = container.querySelectorAll(`[name^="${kwd}_ELEM"]`);

        if (isSngVal) {
          // SngVal selected - disable and clear all ELEM inputs
          elemInputs.forEach(input => {
            input.disabled = true;
            if (input.tagName.toLowerCase() === 'vscode-single-select') {
              input.value = "";
            } else if (input.tagName.toLowerCase() === 'vscode-textfield') {
              input.value = "";
            } else {
              input.value = "";
            }
          });

          // Add visual indication
          elemInputs.forEach(input => {
            const parent = input.closest('.form-div');
            if (parent) {
              parent.style.opacity = '0.5';
              parent.title = 'Disabled because single value is selected above';
            }
          });
        } else {
          // No SngVal selected - enable all ELEM inputs
          elemInputs.forEach(input => {
            input.disabled = false;
            const parent = input.closest('.form-div');
            if (parent) {
              parent.style.opacity = '1';
              parent.title = '';
            }
          });
        }
      }

      // Listen for changes
      sngValSelect.addEventListener('change', updateSngValLocking);

      // Initial setup
      updateSngValLocking();
    }

    function getDropdownOrCustomValue(selectElem) {
      if (selectElem && selectElem.dataset.customInputId) {
        const customInput = document.getElementById(selectElem.dataset.customInputId);
        if (customInput && customInput.value.trim() !== "") {
          return customInput.value.trim();
        } else {
          return selectElem.value;
        }
      }
      return selectElem.value;
    }

    function renderParmInstance(parm, kwd, idx, max, multiGroupDiv) {
      const type = (parm.getAttribute("Type") || "").toUpperCase();
      const prompt = parm.getAttribute("Prompt") || kwd;
      const dft = parm.getAttribute("Dft") || "";
      const len = parm.getAttribute("Len") || "";
      const required = parm.getAttribute("Min") === "1";
      const instanceId = `${kwd}_INST${idx}`;

      const div = document.createElement("div");
      div.className = "parm-instance";
      div.dataset.kwd = kwd;

      // Determine parameter type and render accordingly
      const isElem = (type === "ELEM" || parm.getElementsByTagName("Elem").length > 0);
      const isQual = parm.getElementsByTagName("Qual").length > 0;

      // Add label for simple parameters only
      if (!isElem && !isQual) {
        addParameterLabel(div, prompt, kwd, idx, max, instanceId);
      }

      // Render based on parameter type
      if (isElem) {
        renderElemParameter(parm, kwd, idx, div, prompt, dft, max); // ✅ Pass max
      } else if (isQual) {
        renderQualParameter(parm, kwd, div, prompt, idx, max); // ✅ Pass idx and max
      } else {
        renderSimpleParameter(parm, kwd, div, dft, required, instanceId);
      }

      // Add multi-instance controls
      if (max > 1 && multiGroupDiv) {
        addMultiInstanceControls(div, parm, kwd, idx, max, multiGroupDiv);
      }

      return div;
    }

    function addParameterLabel(container, prompt, kwd, idx, max, instanceId) {
      const label = document.createElement("label");
      label.className = "form-label";

      let labelText = prompt;
      if (idx === 0 && kwd && !prompt.includes(`(${kwd})`)) {
        labelText += ` (${kwd})`;
      }
      if (max > 1) {
        labelText += ` [${idx + 1}]`;
      }

      label.textContent = labelText;
      label.htmlFor = instanceId;
      container.appendChild(label);
    }

    function renderElemParameter(parm, kwd, idx, container, prompt, dft, max = 1) {
      console.log(`[clPrompter] Processing ELEM parameter: ${kwd}, instance: ${idx}, max: ${max}`);

      const fieldset = document.createElement("fieldset");
      fieldset.className = "elem-group";

      // Add legend
      const legend = document.createElement("legend");
      let legendText = prompt;
      if (idx === 0 && kwd && !prompt.includes(`(${kwd})`)) {
        legendText += ` (${kwd})`;
      }
      if (max > 1) {
        legendText += ` [${idx + 1}]`;
      }
      legend.textContent = legendText;
      fieldset.appendChild(legend);


      const isMultiInstance = max > 1;
      addElemChildren(fieldset, parm, kwd, idx, isMultiInstance);

      container.appendChild(fieldset);
      console.log(`[clPrompter] Completed ELEM parameter: ${kwd}`);
    }

    function addSngValControl(container, parm, kwd, prompt, dft, sngVal, instanceIdx = 0, isMultiInstance = false) {
      console.log(`[clPrompter] Adding SngVal for ${kwd}, instance: ${instanceIdx}`);

      const sngValDiv = document.createElement("div");
      sngValDiv.className = "form-div";

      const sngValLabel = document.createElement("label");
      sngValLabel.className = "form-label";
      sngValLabel.textContent = prompt;

      const sngValId = isMultiInstance ? `${kwd}_SNGVAL_${instanceIdx}` : `${kwd}_SNGVAL`;
      sngValLabel.htmlFor = sngValId;
      sngValDiv.appendChild(sngValLabel);

      // Create VS Code Elements combobox for SngVal
      const sngValSelect = document.createElement("vscode-single-select");
      sngValSelect.id = sngValId;
      sngValSelect.name = sngValId;
      sngValSelect.setAttribute("combobox", "");

      if (dft) {
        sngValSelect.setAttribute('data-default', dft);
      }

      // ✅ Add empty option first
      const emptyOption = document.createElement("vscode-option");
      emptyOption.value = "";
      emptyOption.textContent = "(specify individual elements)"; // ✅ More descriptive text
      sngValSelect.appendChild(emptyOption);

      // ✅ Add SngVal options in their own group
      const sngValues = sngVal.querySelectorAll("Value");
      if (sngValues.length > 0) {
        const sngGroup = document.createElement("optgroup");
        sngGroup.label = "Single Values";

        sngValues.forEach(val => {
          const option = document.createElement("vscode-option");
          option.value = val.getAttribute("Val");
          option.textContent = val.getAttribute("Val");
          option.setAttribute("data-sngval", "true");

          // Select default option
          if (val.getAttribute("Val") === dft) {
            option.selected = true;
            sngValSelect.value = dft;
          }

          sngGroup.appendChild(option);
        });

        sngValSelect.appendChild(sngGroup);
      }

      // ✅ Add Values options (if any)
      const values = parm.querySelector("Values");
      if (values) {
        const valuesGroup = document.createElement("optgroup");
        valuesGroup.label = "Values";

        const valueElements = values.querySelectorAll("Value");
        valueElements.forEach(val => {
          const valText = val.getAttribute("Val");

          // Don't duplicate SngVal entries
          const isDuplicate = Array.from(sngValues).some(sngVal =>
            sngVal.getAttribute("Val") === valText
          );

          if (!isDuplicate) {
            const option = document.createElement("vscode-option");
            option.value = valText;
            option.textContent = valText;

            if (valText === dft) {
              option.selected = true;
              sngValSelect.value = dft;
            }

            valuesGroup.appendChild(option);
          }
        });

        if (valuesGroup.children.length > 0) {
          sngValSelect.appendChild(valuesGroup);
        }
      }

      // ✅ Add SpcVal options last
      const spcVal = parm.querySelector("SpcVal");
      if (spcVal) {
        const spcGroup = document.createElement("optgroup");
        spcGroup.label = "Special Values";

        const spcValues = spcVal.querySelectorAll("Value");
        spcValues.forEach(val => {
          const valText = val.getAttribute("Val");

          // Don't duplicate SngVal or Values entries
          const isDuplicate =
            Array.from(sngValues).some(sngVal => sngVal.getAttribute("Val") === valText) ||
            (values && Array.from(values.querySelectorAll("Value")).some(value => value.getAttribute("Val") === valText));

          if (!isDuplicate) {
            const option = document.createElement("vscode-option");
            option.value = valText;
            option.textContent = valText;

            if (valText === dft) {
              option.selected = true;
              sngValSelect.value = dft;
            }

            spcGroup.appendChild(option);
          }
        });

        if (spcGroup.children.length > 0) {
          sngValSelect.appendChild(spcGroup);
        }
      }

      sngValDiv.appendChild(sngValSelect);
      container.appendChild(sngValDiv);
    }

    function setupSngValLockingForNestedElements(container, sngValSelectId, nestedContainer) {
      const sngValSelect = container.querySelector(`#${sngValSelectId}`);
      if (!sngValSelect) return;

      function updateNestedElementsVisibility() {
        const selectedOption = sngValSelect.selectedOptions[0];
        const isSngVal = selectedOption && selectedOption.getAttribute("data-sngval") === "true";
        const hasValue = sngValSelect.value && sngValSelect.value.trim() !== "";

        console.log(`[clPrompter] SngVal changed: value="${sngValSelect.value}", isSngVal=${isSngVal}`);

        if (isSngVal || hasValue) {
          // SngVal selected or any value entered - hide nested elements
          nestedContainer.style.display = "none";
          console.log(`[clPrompter] Hiding nested elements (SngVal selected)`);
        } else {
          // No value or empty selection - show nested elements
          nestedContainer.style.display = "block";
          console.log(`[clPrompter] Showing nested elements (no SngVal)`);
        }
      }

      // Listen for changes
      sngValSelect.addEventListener('change', updateNestedElementsVisibility);
      sngValSelect.addEventListener('input', updateNestedElementsVisibility);

      // Initial setup
      updateNestedElementsVisibility();
    }

    function addElemChildren(container, parm, kwd, instanceIdx = 0, isMultiInstance = false) {
      // ✅ Use ":scope > Elem" to get only DIRECT child Elem elements
      const elems = parm.querySelectorAll(":scope > Elem");
      console.log(`[clPrompter] Processing ${elems.length} DIRECT Elem children for ${kwd}, isMultiInstance: ${isMultiInstance}`);

      for (let e = 0; e < elems.length; e++) {
        const elem = elems[e];
        const elemPrompt = elem.getAttribute("Prompt") || elem.getAttribute("Name") || `Element ${e + 1}`;
        const elemType = elem.getAttribute("Type") || "CHAR";
        const elemLen = elem.getAttribute("Len") || "";
        const elemDft = elem.getAttribute("Dft") || "";

        // ✅ Use instance suffix only for multi-instance parameters
        const elemName = isMultiInstance ? `${kwd}_ELEM${e}_${instanceIdx}` : `${kwd}_ELEM${e}`;

        console.log(`[clPrompter] Creating elem ${e}: ${elemName}, type: ${elemType}, default: ${elemDft}`);

        // ✅ Handle nested ELEM (ELEM within ELEM) - like TOPGMQ's "Call stack entry identifier"
        // ✅ Update the nested ELEM creation in addElemChildren
        // ✅ Handle nested ELEM (ELEM within ELEM) - use numeric pattern
        if (elemType === "ELEM") {
          console.log(`[clPrompter] Found nested ELEM: ${elemName}`);

          // Create a sub-fieldset for the nested ELEM
          const subFieldset = document.createElement("fieldset");
          subFieldset.className = "elem-group nested-elem-group";
          subFieldset.style.marginLeft = "15px";
          subFieldset.style.border = "1px solid #aaa";
          subFieldset.style.backgroundColor = "#f5f5f5";

          const subLegend = document.createElement("legend");
          subLegend.textContent = elemPrompt;
          subFieldset.appendChild(subLegend);

          // ✅ Process the sub-elements with numeric pattern
          const subElems = elem.querySelectorAll(":scope > Elem");
          for (let se = 0; se < subElems.length; se++) {
            const subElem = subElems[se];
            const subElemPrompt = subElem.getAttribute("Prompt") || `Sub-element ${se + 1}`;
            const subElemType = subElem.getAttribute("Type") || "CHAR";
            const subElemLen = subElem.getAttribute("Len") || "";
            const subElemDft = subElem.getAttribute("Dft") || "";

            // ✅ NEW: Use numeric pattern - ELEM#_index
            const subElemName = `${elemName}_${se}`;

            console.log(`[clPrompter] Creating sub-elem ${se}: ${subElemName}, type: ${subElemType}`);

            const subElemDiv = document.createElement("div");
            subElemDiv.className = "form-div";

            const subElemLabel = document.createElement("label");
            subElemLabel.className = "form-label";
            subElemLabel.textContent = subElemPrompt;
            subElemLabel.htmlFor = subElemName;
            subElemDiv.appendChild(subElemLabel);

            // Create input for sub-element
            const subElemInput = createElemInput(subElem, subElemName, subElemType, subElemLen, subElemDft, kwd);
            subElemDiv.appendChild(subElemInput);
            subFieldset.appendChild(subElemDiv);
          }

          container.appendChild(subFieldset);

        } else {
          // ✅ Regular element - DON'T add level indicator for simple ELEMs
          const elemDiv = document.createElement("div");
          elemDiv.className = "form-div";

          const elemLabel = document.createElement("label");
          elemLabel.className = "form-label";
          elemLabel.textContent = elemPrompt;

          // ✅ Use simple naming for regular elements: LOG_ELEM0, not LOG_ELEM0_0
          elemLabel.htmlFor = elemName; // Use elemName directly
          elemDiv.appendChild(elemLabel);

          // Create appropriate input based on allowed values
          const elemInput = createElemInput(elem, elemName, elemType, elemLen, elemDft, kwd); // Use elemName
          elemDiv.appendChild(elemInput);
          container.appendChild(elemDiv);
        }
      }
    }

    // ✅ Update createElemInput function around line 2890:
    function createElemInput(elem, elemName, elemType, elemLen, elemDft, kwd) {
      let allowedVals = allowedValsMap[elemName] || [];
      const noCustomInput = allowedVals._noCustomInput === true;

      // ✅ CRITICAL FIX: If allowedValsMap is empty, extract SpcVals directly from ELEM XML
      if (allowedVals.length === 0) {
        console.log(`[createElemInput] ${elemName}: allowedValsMap empty, checking XML for SpcVal/SngVal`);

        const xmlSpcVals = [];

        // Check SpcVal
        const spcVal = elem.querySelector('SpcVal');
        if (spcVal) {
          const spcValues = spcVal.querySelectorAll('Value');
          spcValues.forEach(val => {
            const valText = val.getAttribute('Val');
            if (valText) {
              xmlSpcVals.push(valText);
            }
          });
        }

        // Check SngVal
        const sngVal = elem.querySelector('SngVal');
        if (sngVal) {
          const sngValues = sngVal.querySelectorAll('Value');
          sngValues.forEach(val => {
            const valText = val.getAttribute('Val');
            if (valText) {
              xmlSpcVals.push(valText);
            }
          });
        }

        // Check Values
        const values = elem.querySelector('Values');
        if (values) {
          const valueElements = values.querySelectorAll('Value');
          valueElements.forEach(val => {
            const valText = val.getAttribute('Val');
            if (valText) {
              xmlSpcVals.push(valText);
            }
          });
        }

        if (xmlSpcVals.length > 0) {
          allowedVals = xmlSpcVals;
          console.log(`[createElemInput] ${elemName}: Found ${xmlSpcVals.length} values in XML:`, xmlSpcVals);
        }
      }

      let elemInput;

      // ✅ Calculate width using the correct allowedVals (from map OR XML)
      const effectiveLen = calculateFieldWidth(elem, allowedVals);
      const widthClass = getLengthClass(effectiveLen);

      console.log(`[createElemInput] ${elemName}: effectiveLen=${effectiveLen}, widthClass=${widthClass}, allowedVals=${allowedVals.length}`);

      if (allowedVals.length > 0) {
        // Create parameter input with calculated width
        elemInput = createParameterInput(elemName, allowedVals, noCustomInput, elemDft);

        // Apply the calculated width class
        if (elemInput.className) {
          elemInput.className = widthClass;
        }
      } else {
        // ✅ For elements without allowedVals, force CHAR type to prevent number inputs
        const safeElemType = 'CHAR';

        // Create regular input with calculated width
        elemInput = createInputForType(safeElemType, elemName, elemDft, elemLen);

        // Apply the calculated width class
        if (elemInput.className) {
          elemInput.className = widthClass;
        }

        if (elemDft) {
          elemInput.setAttribute('data-default', elemDft);
        }
      }

      // Set common attributes
      elemInput.name = elemName;
      elemInput.id = elemName;

      return elemInput;
    }

    function createVSCodeSelect(name, spcValElement, defaultValue = "") {
      const select = document.createElement("vscode-single-select");
      select.setAttribute("combobox", "");

      // Add empty option if no default
      if (!defaultValue) {
        const emptyOption = document.createElement("vscode-option");
        emptyOption.value = "";
        emptyOption.textContent = "";
        select.appendChild(emptyOption);
      }

      // Add options from SpcVal
      const values = spcValElement.querySelectorAll("Value");
      values.forEach(val => {
        const option = document.createElement("vscode-option");
        option.value = val.getAttribute("Val");
        option.textContent = val.getAttribute("Val");

        if (val.getAttribute("Val") === defaultValue) {
          option.selected = true;
          select.value = defaultValue;
        }

        select.appendChild(option);
      });

      if (defaultValue) {
        select.setAttribute('data-default', defaultValue);
      }

      return select;
    }

    function renderQualParameter(parm, kwd, container, prompt, instanceIdx = 0, max = 1) {
      const quals = parm.getElementsByTagName("Qual");
      const fieldset = document.createElement("fieldset");
      fieldset.className = "qual-group";

      const legend = document.createElement("legend");
      let legendText = prompt;
      if (kwd && !prompt.includes(`(${kwd})`)) {
        legendText += ` (${kwd})`;
      }
      if (max > 1) {
        legendText += ` [${instanceIdx + 1}]`;
      }
      legend.textContent = legendText;
      fieldset.appendChild(legend);

      const isMultiInstance = max > 1;

      for (let q = 0; q < quals.length; q++) {
        const qual = quals[q];
        const qualPrompt = (q === 0)
          ? prompt  // First QUAL uses parameter prompt
          : (qual.getAttribute("Prompt") || `Qualifier ${q + 1}`); // Others use their own


        const qualType = qual.getAttribute("Type") || "CHAR";
        const qualLen = qual.getAttribute("Len") || "";
        const qualDft = qual.getAttribute("Dft") || "";

        // ✅ Use instance suffix only for multi-instance parameters
        const qualName = isMultiInstance ? `${kwd}_QUAL${q}_${instanceIdx}` : `${kwd}_QUAL${q}`;

        console.log(`[clPrompter] Creating qual ${q}: ${qualName}, type: ${qualType}, default: ${qualDft}`);

        const qualDiv = document.createElement("div");
        qualDiv.className = "form-div";

        const qualLabel = document.createElement("label");
        qualLabel.className = "form-label";
        qualLabel.textContent = qualPrompt;
        qualLabel.htmlFor = qualName;
        qualDiv.appendChild(qualLabel);

        // Create appropriate input for qualifier
        const qualInput = createQualInput(qual, qualName, qualType, qualLen, qualDft);
        qualDiv.appendChild(qualInput);
        fieldset.appendChild(qualDiv);
      }

      container.appendChild(fieldset);
    }

    function createQualInput(qual, qualName, qualType, qualLen, qualDft) {
      const allowedVals = allowedValsMap[qualName] || [];
      const noCustomInput = allowedVals._noCustomInput === true;

      let qualInput;
      if (allowedVals.length > 0) {
        // Use allowed values from allowedValsMap
        qualInput = createParameterInput(qualName, allowedVals, noCustomInput, qualDft);
      } else {
        // Check for SpcVal in the qualifier itself
        const qualSpcVal = qual.querySelector("SpcVal");
        if (qualSpcVal) {
          qualInput = createVSCodeSelect(qualName, qualSpcVal, qualDft);
        } else {
          // Create regular input
          qualInput = createInputForType(qualType, qualName, qualDft, qualLen);
          if (qualDft) {
            qualInput.setAttribute('data-default', qualDft);
          }
        }
      }

      // Set common attributes
      qualInput.name = qualName;
      qualInput.id = qualName;

      return qualInput;
    }

    function createSimpleParameterCombobox(parm, kwd, dft, spcVal, sngVal) {
      const select = document.createElement("vscode-single-select");
      select.setAttribute("combobox", "");

      // Set default value as data attribute
      if (dft) {
        select.setAttribute('data-default', dft);
      }

      // ✅ Add SngVal options first (if present)
      if (sngVal) {
        const sngValues = sngVal.querySelectorAll("Value");
        sngValues.forEach(val => {
          const option = document.createElement("vscode-option");
          option.value = val.getAttribute("Val");
          option.textContent = val.getAttribute("Val");
          option.setAttribute("data-sngval", "true"); // Mark as single value

          // Select default option
          if (val.getAttribute("Val") === dft) {
            option.selected = true;
            select.value = dft;
          }

          select.appendChild(option);
        });
      }

      // ✅ Add SpcVal options (if present)
      if (spcVal) {
        const spcValues = spcVal.querySelectorAll("Value");
        spcValues.forEach(val => {
          const valText = val.getAttribute("Val");

          // Don't duplicate SngVal entries
          const existingOption = select.querySelector(`vscode-option[value="${valText}"]`);
          if (!existingOption) {
            const option = document.createElement("vscode-option");
            option.value = valText;
            option.textContent = valText;

            // Select default option
            if (valText === dft) {
              option.selected = true;
              select.value = dft;
            }

            select.appendChild(option);
          }
        });
      }

      // ✅ If no default was set and no options exist, add empty option
      if (!select.value && select.children.length === 0) {
        const emptyOption = document.createElement("vscode-option");
        emptyOption.value = "";
        emptyOption.textContent = "";
        select.appendChild(emptyOption);
      }

      return select;
    }

    function renderSimpleParameter(parm, kwd, container, dft, required, instanceId) {
      console.log(`[clPrompter] renderSimpleParameter: ${kwd}, default: ${dft}`);

      try {
        const allowedVals = allowedValsMap[kwd] || [];
        const spcVal = parm.querySelector("SpcVal");
        const sngVal = parm.querySelector("SngVal");
        const isRestricted = parm.getAttribute("Rstd") === "YES";

        console.log(`[clPrompter] ${kwd} - allowedVals: ${allowedVals.length}, spcVal: ${!!spcVal}, sngVal: ${!!sngVal}`);

        let input;

        if (allowedVals.length > 0) {
          console.log(`[clPrompter] ${kwd} - Using allowedValsMap`);
          input = createParameterInput(kwd, allowedVals, false, dft);
        } else if (spcVal || sngVal || isRestricted) {
          console.log(`[clPrompter] ${kwd} - Creating combobox from XML`);
          input = createSimpleParameterCombobox(parm, kwd, dft, spcVal, sngVal);
        } else {
          console.log(`[clPrompter] ${kwd} - Creating regular text input`);
          const parmType = parm.getAttribute("Type") || "CHAR";
          const parmLen = parm.getAttribute("Len") || "";
          console.log(`[clPrompter] ${kwd} - About to call createInputForType with type: ${parmType}`);
          input = createInputForType(parmType, kwd, dft, parmLen);
        }

        input.id = instanceId;
        input.name = kwd;

        if (required) {
          input.required = true;
        }

        console.log(`[clPrompter] About to append input for ${kwd} to container`);
        container.appendChild(input);
        console.log(`[clPrompter] Successfully appended input for ${kwd}`);

      } catch (error) {
        console.error(`[clPrompter] Error in renderSimpleParameter for ${kwd}:`, error);
        // Create a fallback input
        const fallbackInput = document.createElement("input");
        fallbackInput.type = "text";
        fallbackInput.name = kwd;
        fallbackInput.id = instanceId;
        container.appendChild(fallbackInput);
      }
    }

    function addMultiInstanceControls(container, parm, kwd, idx, max, multiGroupDiv) {
      if (idx === 0) {
        // Add button for first instance
        const addBtn = document.createElement("button");
        addBtn.type = "button";
        addBtn.className = "add-parm-btn";
        addBtn.textContent = "+";
        addBtn.title = "Add another instance";
        addBtn.onclick = function () {
          const instances = multiGroupDiv.querySelectorAll(".parm-instance");
          if (instances.length < max) {
            const newIdx = instances.length;
            const newDiv = renderParmInstance(parm, kwd, newIdx, max, multiGroupDiv);
            multiGroupDiv.appendChild(newDiv);
          }
        };
        container.appendChild(addBtn);
      } else {
        // Remove button for subsequent instances
        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "remove-parm-btn";
        removeBtn.textContent = "-";
        removeBtn.title = "Remove this instance";
        removeBtn.onclick = function () {
          container.remove();
        };
        container.appendChild(removeBtn);
      }
    }



    // --- Main form rendering ---
    function loadForm() {
      console.log("loadForm called, xmlDoc:", xmlDoc);
      if (!xmlDoc) return;
      const form = document.getElementById("clForm");
      form.innerHTML = "";

      parms.forEach(parm => {
        const kwd = parm.getAttribute("Kwd");
        const type = parm.getAttribute("Type");
        const constant = parm.getAttribute("Constant"); // Check for Constant attribute
        const max = parseInt(parm.getAttribute("Max") || "1", 10);

        // ✅ Skip parameters with Constant attribute (not Type="CONSTANT")
        if (constant) {
          console.log(`[clPrompter] Skipping CONSTANT parameter: ${kwd} (Constant=${constant})`);
          return; // Skip this parameter
        }

        // ✅ Skip NULL parameters (Type="Null" from TYPE(*NULL))
        if (type === "Null") {
          console.log(`[clPrompter] Skipping NULL parameter: ${kwd} (Type=${type})`);
          return; // Skip this parameter
        }

        // Multi-instance group
        if (max > 1) {
          const multiGroupDiv = document.createElement("div");
          multiGroupDiv.className = "parm-multi-group";
          multiGroupDiv.dataset.kwd = kwd;
          multiGroupDiv.dataset.max = max;
          // Render first instance
          multiGroupDiv.appendChild(renderParmInstance(parm, kwd, 0, max, multiGroupDiv));
          form.appendChild(multiGroupDiv);
        } else {
          // Single instance
          form.appendChild(renderParmInstance(parm, kwd, 0, 1, null));
        }
      });
    }

    function validateRestrictedInput(input) {
      if (input.getAttribute('data-restricted') === 'true') {
        const options = Array.from(input.querySelectorAll('vscode-option'));
        const allowedValues = options.map(opt => opt.value);

        if (input.value && !allowedValues.includes(input.value)) {
          // Show validation error or auto-correct
          console.warn(`Invalid value: ${input.value}. Allowed: ${allowedValues.join(', ')}`);
          return false;
        }
      }
      return true;
    }

    function getInputValue(input) {
      console.log(`[clPrompter] getInputValue - tagName: ${input.tagName}, name: ${input.name}`);

      // Handle VS Code Elements combobox
      if (input.tagName.toLowerCase() === 'vscode-single-select') {
        const value = input.value || '';
        console.log(`[clPrompter] getInputValue - VS Code select value: "${value}"`);
        return value;
      }

      // Handle VS Code textfield
      if (input.tagName.toLowerCase() === 'vscode-textfield') {
        const value = input.value || '';
        console.log(`[clPrompter] getInputValue - VS Code textfield value: "${value}"`);
        return value;
      }

      // Handle old dropdown with custom input
      if (input.tagName === 'SELECT' && input.dataset.customInputId) {
        const value = getDropdownOrCustomValue(input);
        console.log(`[clPrompter] getInputValue - HTML select+custom value: "${value}"`);
        return value;
      }

      // Handle regular inputs
      const value = input.value || '';
      console.log(`[clPrompter] getInputValue - Regular input value: "${value}"`);
      return value;
    }

    function isUnchangedDefault(input, value) {
      const defaultValue = input.getAttribute('data-default');
      if (!defaultValue) return false;

      // Value matches default exactly
      if (value === defaultValue) return true;

      // ✅ Don't treat empty values as unchanged defaults for QUAL parameters
      if (input.name && input.name.includes('_QUAL')) {
        return false; // Never skip QUAL parameters due to defaults
      }

      // Handle empty value when default exists
      if (!value && defaultValue) return true;

      return false;
    }

    // ✅ Add this function before the submit handler (around line 800-900)
    function validateRangeInput(input) {
      const fromValue = input.getAttribute('data-range-from');
      const toValue = input.getAttribute('data-range-to');

      if (!fromValue || !toValue) return true; // No range to validate

      const value = input.value.trim();

      // Allow empty values (they're optional)
      if (!value) return true;

      // ✅ Check if value matches any SpcVal or SngVal entries first
      const inputName = input.name || input.id;
      const allowedVals = allowedValsMap[inputName] || [];

      // If value matches any allowed special value, it's valid regardless of range
      if (allowedVals.includes(value)) {
        console.log(`[clPrompter] Range validation: "${value}" matches allowed special value`);
        return true;
      }

      // ✅ Allow any value that starts with * (special values)
      if (value.startsWith('*')) {
        console.log(`[clPrompter] Range validation: "${value}" is special value (starts with *)`);
        return true;
      }

      // ✅ Allow any value that starts with & (CL variables)
      if (value.startsWith('&')) {
        console.log(`[clPrompter] Range validation: "${value}" is CL variable (starts with &)`);
        return true;
      }

      // Validate numeric range
      const numValue = parseInt(value, 10);
      const fromNum = parseInt(fromValue, 10);
      const toNum = parseInt(toValue, 10);

      if (isNaN(numValue) || isNaN(fromNum) || isNaN(toNum)) {
        console.log(`[clPrompter] Range validation: non-numeric values - value: "${value}", range: ${fromValue}-${toValue}`);
        return true; // Can't validate non-numeric, assume valid
      }

      const isValid = numValue >= fromNum && numValue <= toNum;

      if (!isValid) {
        console.log(`[clPrompter] Range validation failed: ${value} not in range ${fromValue}-${toValue}`);

        // Add visual indication
        input.classList.add('invalid');

        // Show error tooltip
        showRangeTooltip(input, `❌ Value ${value} is outside valid range ${fromValue}-${toValue}`, 'error');

        return false;
      } else {
        // Remove visual indication
        input.classList.remove('invalid');
        console.log(`[clPrompter] Range validation passed: ${value} is within range ${fromValue}-${toValue}`);
        return true;
      }
    }

    // --- SUBMIT HANDLER ---
    document.getElementById("submitBtn").addEventListener("click", e => {
      try {
        e.preventDefault();
        if (!xmlDoc) return;
        const values = {};
        const qualGroups = {};

        // --- 1. MULTI-INSTANCE (MAX > 1) PARAMETERS ---
        document.querySelectorAll(".parm-multi-group").forEach(group => {
          const kwd = group.dataset.kwd;
          const parm = Array.from(parms).find(p => p.getAttribute("Kwd") === kwd);
          if (!parm) return;
          let max = parseInt(group.dataset.max, 10);
          const instances = group.querySelectorAll(".parm-instance");
          let instanceVals = [];
          instances.forEach((inst, idx) => {
            if ((parm.getAttribute("Type") || "").toUpperCase() === "ELEM") {
              const elems = parm.getElementsByTagName("Elem");
              let elemVals = [];
              for (let e = 0; e < elems.length; e++) {
                const elemName = `${kwd}_ELEM${e}_${idx}`;
                const input = inst.querySelector(`[name="${elemName}"]`);
                let val = input ? input.value : "";
                if (val === "" || val === undefined || val === null || val === "*N") continue;
                const elemType = (elems[e].getAttribute("Type") || "").toUpperCase();
                elemVals.push(val);
              }
              const filtered = elemVals.filter(v => v !== "*N" && v !== "" && v !== "''");
              if (filtered.length > 0) {
                instanceVals.push(filtered.join(" "));
              }
            } else {
              let input = inst.querySelector(`select[name^="${kwd}_"]`) || inst.querySelector(`select[name="${kwd}_${idx}"]`) || inst.querySelector(`select[name="${kwd}"]`);
              let val = "";
              if (input) {
                val = getInputValue(input);
              } else {
                input = inst.querySelector(`[name^="${kwd}_"]`) || inst.querySelector(`[name="${kwd}_${idx}"]`) || inst.querySelector(`[name="${kwd}"]`);
                val = input ? input.value : "";
              }
              if (val === "" || val === undefined || val === null) return;
              const parmType = parm && parm.getAttribute("Type") ? parm.getAttribute("Type").toUpperCase() : "";
              if (parmType === "NAME" && val) val = val.toUpperCase();
              instanceVals.push(val);
            }
          });
          if (instanceVals.length > 0) {
            values[kwd] = instanceVals;
          } else if (originalParamMap.hasOwnProperty(kwd)) {
            let orig = originalParamMap[kwd];
            if (Array.isArray(orig)) {
              values[kwd] = orig;
            } else if (typeof orig === "string") {
              values[kwd] = orig.trim().split(/\s+/);
            } else {
              values[kwd] = String(orig);
            }
          }
        });

        // --- 2. SINGLE-INSTANCE PARAMETERS (not in multi-groups) ---
        const form = document.getElementById('clForm');
        const inputs = form.querySelectorAll('input, select, textarea, vscode-single-select, vscode-textfield, vscode-textarea');
        inputs.forEach(i => {
          if (i.closest('.parm-multi-group')) return;
          if (!i.name) return;

          // ✅ Add debug logging for TOPGMQ inputs
          if (i.name.includes('TOPGMQ')) {
            console.log(`[clPrompter] Submit - TOPGMQ input: name="${i.name}", value="${i.value}", tagName=${i.tagName}`);
          }


          let parmType = "CHAR";
          let parmElem = null;
          for (let p = 0; p < parms.length; p++) {
            const kwd = parms[p].getAttribute("Kwd");
            if (i.name.startsWith(kwd)) {
              parmElem = parms[p];
              break;
            }
          }
          if (!parmElem) return;

          const parmKwd = parmElem.getAttribute("Kwd");
          if (parmElem.hasAttribute("Type")) parmType = parmElem.getAttribute("Type").toUpperCase();

          let val = getInputValue(i);

          console.log(`[clPrompter] Submit - Processing ${i.name}, value: "${val}", tagName: ${i.tagName}`);

          // ✅ Skip if value is unchanged default
          if (isUnchangedDefault(i, val)) {
            console.log(`[clPrompter] Skipping ${i.name} - unchanged default: ${val}`);
            return;
          }

          const qualMatch = i.name.match(/^(.+?)_QUAL(\d+)$/);
          if (qualMatch) {
            const parmName = qualMatch[1];
            const qualIndex = parseInt(qualMatch[2], 10);
            if (!qualGroups[parmName]) qualGroups[parmName] = [];
            qualGroups[parmName].push({ qual: `QUAL${qualIndex}`, value: val, index: qualIndex });
            console.log(`[clPrompter] Submit - Added QUAL: ${parmName} QUAL${qualIndex} = "${val}" (index: ${qualIndex})`);
            console.log(`[clPrompter] Submit - Current qualGroups[${parmName}]:`, qualGroups[parmName]);
            return;
          }

          if (i.name.match(/_ELEM\d+$/)) {
            // ✅ Don't store ELEM values with unchanged defaults
            if (val !== "" && val !== "''" && val !== '""') {
              values[i.name] = val;
            }
            return;
          }

          const wasInOriginal = originalParamMap.hasOwnProperty(parmKwd);
          if (val !== "" && val !== "''" && val !== '""') {
            // ✅ Only include if it's NOT an unchanged default
            if (!isUnchangedDefault(i, val)) {
              values[parmKwd] = val;
              console.log(`[clPrompter] Including changed parameter: ${parmKwd} = "${val}"`);
            } else {
              console.log(`[clPrompter] Skipping unchanged default: ${parmKwd} = "${val}"`);
            }
          } else if (wasInOriginal) {
            values[parmKwd] = originalParamMap[parmKwd];
            console.log(`[clPrompter] Restoring original parameter: ${parmKwd}`);
          }
        });


        // --- 3. ELEM PARAMETER ASSEMBLY (single instance) ---
        for (let i = 0; i < parms.length; i++) {
          const parm = parms[i];
          const kwd = parm.getAttribute("Kwd");
          if ((parm.getAttribute("Type") || "").toUpperCase() === "ELEM" && !document.querySelector(`.parm-multi-group[data-kwd="${kwd}"]`)) {

            // CHECK: First check if SngVal is selected
            const sngValInput = document.querySelector(`[name="${kwd}_SNGVAL"]`);
            if (sngValInput && sngValInput.value) {
              const selectedOption = sngValInput.selectedOptions[0];
              if (selectedOption && selectedOption.getAttribute("data-sngval") === "true") {
                // ✅ Check if SngVal is unchanged default
                if (!isUnchangedDefault(sngValInput, sngValInput.value)) {
                  values[kwd] = [sngValInput.value];
                }
                continue;
              }
            }

            // No SngVal selected - process ELEM values normally
            const elems = parm.getElementsByTagName("Elem");
            let hasNonDefaultValues = false;

            // ✅ Process each ELEM element
            for (let e = 0; e < elems.length; e++) {
              const elemName = `${kwd}_ELEM${e}`;
              const elem = elems[e];

              // ✅ Handle nested ELEM (ELEM within ELEM)
              if (elem.getAttribute("Type") === "ELEM") {
                console.log(`[clPrompter] Processing nested ELEM: ${elemName}`);
                const subElems = elem.getElementsByTagName("Elem");

                for (let se = 0; se < subElems.length; se++) {
                  const subElemName = `${elemName}_${se}`;  // ✅ Use correct naming pattern
                  const subInput = document.querySelector(`[name="${subElemName}"]`);
                  if (subInput) {
                    let subVal = getInputValue(subInput);
                    if (subVal && subVal.trim() !== "" && !isUnchangedDefault(subInput, subVal)) {
                      values[subElemName] = subVal;
                      hasNonDefaultValues = true;
                      console.log(`[clPrompter] Added nested ELEM value: ${subElemName} = "${subVal}"`);
                    }
                  }
                }
              } else {
                // ✅ Regular ELEM processing
                const input = document.querySelector(`[name="${elemName}"]`);
                if (input) {
                  let val = getInputValue(input);
                  // ✅ Special case: Always include ELEM0 even if it's a default
                  const isFirstElement = elemName.endsWith('_ELEM0');

                  if (val && val.trim() !== "" && (!isUnchangedDefault(input, val) || isFirstElement)) {
                    values[elemName] = val;
                    hasNonDefaultValues = true;
                    console.log(`[clPrompter] Added regular ELEM value: ${elemName} = "${val}"`);
                  }
                }
              }
            }

            // ✅ If no non-default values found, use original values
            if (!hasNonDefaultValues && originalParamMap.hasOwnProperty(kwd)) {
              let orig = originalParamMap[kwd];
              if (Array.isArray(orig)) {
                values[kwd] = orig;
              } else if (typeof orig === "string") {
                values[kwd] = orig.trim().split(/\s+/);
              } else {
                values[kwd] = [String(orig)];
              }
            }
          }
        }

        // --- 4. QUAL PARAMETER ASSEMBLY (single instance) ---
        for (const parmName in qualGroups) {
          const parm = Array.from(parms).find(p => p.getAttribute("Kwd") === parmName);
          if (!parm || !parm.getElementsByTagName("Qual").length) continue;

          // ✅ Sort by index (QUAL0, QUAL1, QUAL2) - no reverse needed
          const parts = qualGroups[parmName]
            .sort((a, b) => a.index - b.index)  // Sort by numeric index
            .reverse()
            .map(q => q.value)
            .filter(val => val !== "");

          console.log(`[clPrompter] Submit - Assembled QUAL ${parmName}:`, parts);

          if (parts.length > 0) {
            values[parmName] = parts;
          } else if (originalParamMap.hasOwnProperty(parmName)) {
            values[parmName] = originalParamMap[parmName];
          }
        }

        // --- 5. VALIDATE RANGES BEFORE SUBMISSION ---
        let hasValidationErrors = false;
        const rangeInputs = form.querySelectorAll('[data-range-from][data-range-to], [data-range-from][data-range-to] *');

        // ✅ Also check for range inputs inside containers
        const allRangeInputs = [];
        form.querySelectorAll('*').forEach(element => {
          if (element.hasAttribute('data-range-from') && element.hasAttribute('data-range-to')) {
            allRangeInputs.push(element);
          }
        });

        console.log(`[clPrompter] Found ${allRangeInputs.length} range inputs for validation`);

        allRangeInputs.forEach(input => {
          console.log(`[clPrompter] Validating range input: ${input.name}, value: "${input.value}"`);
          if (!validateRangeInput(input)) {
            hasValidationErrors = true;
            console.log(`[clPrompter] Range validation failed for ${input.name}`);

            // Scroll to the first invalid input
            input.scrollIntoView({ behavior: 'smooth', block: 'center' });
            input.focus();
          }
        });

        if (hasValidationErrors) {
          console.log('[clPrompter] Blocking submission due to range validation errors');
          // With this:
          console.error('[clPrompter] Submission blocked due to range validation errors');
          vscode.postMessage({
            type: "error",
            message: "Please correct the invalid range values before submitting."
          });
          return; // Stop submission
        }

        // --- 6. FINAL COMMAND ASSEMBLY --- (renamed from 5)
        let cmdString = cmdName;
        for (const [key, value] of Object.entries(values)) {
          cmdString += ` ${key}(${Array.isArray(value) ? value.join(" ") : value})`;
        }
        const labelInput = document.getElementById("clLabel");
        const labelVal = labelInput && labelInput.value.trim();
        if (labelVal) {
          cmdString = `${labelVal.toUpperCase()}: ${cmdString}`;
        }
        console.log('[clPrompter] Submitting Final values (excluding unchanged defaults):', values);
        vscode.postMessage({ type: "submit", cmdName, values });
      } catch (err) {
        console.error("[clPrompter] Error in submit handler:", err);
        alert("An error occurred: " + err.message);
      }
    });

    function isCLExpression(val) {
      const ops = ['*CAT', '*TCAT', '*BCAT', '*EQ', '*NE', '*LT', '*LE', '*GT', '*GE'];
      const trimmed = val.trim().toUpperCase();
      if (trimmed.startsWith('(') && trimmed.endsWith(')')) return true;
      if (ops.some(op => trimmed.includes(op))) return true;
      if (/%[A-Z][A-Z0-9]*\s*\(/i.test(trimmed)) return true;
      if (/&[A-Z][A-Z0-9]*\s*[*%]/i.test(trimmed)) return true;
      return false;
    }

    document.getElementById("clForm").addEventListener("keydown", function (e) {
      if (e.key === "Enter") {
        e.preventDefault();
        document.getElementById("submitBtn").click();
      }
    });

    document.getElementById("cancelBtn").addEventListener("click", e => {
      e.preventDefault();
      vscode.postMessage({ type: "cancel" });
    });

    window.addEventListener('DOMContentLoaded', () => {
      console.log("[clPrompter] DOM Content Loaded");

      // ✅ Check ALL VS Code Elements components
      setTimeout(() => {
        const availableComponents = [
          'vscode-single-select',
          'vscode-textfield',
          'vscode-textarea',
          'vscode-button',
          'vscode-checkbox',
          'vscode-radio-group',
          'vscode-radio',
          'vscode-option',
          'vscode-divider'
        ];

        console.log("[clPrompter] VS Code Elements availability:");
        availableComponents.forEach(component => {
          const isAvailable = !!customElements.get(component);
          // console.log(`  ${component}: ${isAvailable}`);
        });

      }, 100);

      vscode.postMessage({ type: 'webviewReady' });
      console.log('[clPrompter] Sent webviewReady message');
    });

  </script>
</body>

</html>