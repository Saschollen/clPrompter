<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy"
    content="default-src 'none'; style-src {{cspSource}} 'nonce-{{nonce}}'; script-src 'nonce-{{nonce}}';" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CL Command Prompter</title>
  <style nonce="{{nonce}}">
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      padding: 10px;
    }

    .parm-multi-group {
      border: 1px dashed #bbb;
      margin-bottom: 1em;
      padding: 0.5em;
    }

    .parm-instance {
      margin-bottom: 0.5em;
      padding-bottom: 0.5em;
      border-bottom: 1px dotted #ddd;
    }

    .add-parm-btn,
    .remove-parm-btn {
      font-size: 0.9em;
      padding: 0 0.3em;
      border-radius: 50%;
      width: 1.5em;
      height: 1.5em;
      min-width: 0;
      min-height: 0;
      line-height: 1;
      vertical-align: middle;
      display: inline-block;
      margin: 0 0.2em 0 0;
      box-sizing: border-box;
      border: 1px solid #888;
      background: #f5f5f5;
    }

    .add-parm-btn:focus,
    .remove-parm-btn:focus {
      outline: none;
      border-color: #0078d4;
    }

    .form-label {
      display: inline-block;
      width: 40ch;
      vertical-align: middle;
      margin-bottom: 0.5em;
    }

    .form-input {
      vertical-align: middle;
      margin-bottom: 0.5em;
    }

    .form-div {
      margin-bottom: 0.5em;
    }

    .elem-group {
      border: 1.5px solid #bbb;
      border-radius: 6px;
      margin-bottom: 1em;
      padding: 0.8em 1em 0.5em 1em;
      background: #f8f8f8;
    }

    .elem-group legend {
      font-weight: bold;
      color: #333;
      padding: 0 0.5em;
    }

    button {
      margin-top: 15px;
      font-size: 1.1em;
    }

    .clvar-input {
      margin-left: 0.5em;
      width: 16ch;
    }

    .qual-group .form-label {
      width: auto;
      min-width: 10ch;
      margin-bottom: 0;
      vertical-align: middle;
    }

    .qual-group>div {
      display: flex;
      align-items: center;
      margin-bottom: 0.5em;
      border: 1px dashed red;
      background: #ffe;
    }
  </style>
</head>

<body>
  <div style="margin-bottom: 1em;">
    <label for="clLabel" class="form-label">Label (optional):</label>
    <input type="text" id="clLabel" maxlength="10" style="width: 12ch;" />
  </div>
  <form id="clForm"></form>
  <button id="cancelBtn">Cancel</button>
  <button id="submitBtn">Enter</button>

  <script nonce="{{nonce}}">
    let xmlDoc;
    let caseMode = "MONO";
    let parms = [];
    let allowedValsMap = {};
    let cmdName = "{{cmdName}}";
    let originalParamMap = {};
    const vscode = acquireVsCodeApi();

    console.log("[clPrompter] webview JS loaded");
    window.addEventListener("message", event => {
      const message = event.data;
      if (message.type === "populateForm") {
        originalParamMap = message.paramMap || {};
        populateFormFromValues(message.paramMap);
      }
    });

    window.addEventListener("message", event => {
      const message = event.data;
      if (message.type === "formXml") {
        const parser = new DOMParser();
        xmlDoc = parser.parseFromString(message.xml, "text/xml");
        parms = Array.from(xmlDoc.getElementsByTagName("Parm"));
        buildAllowedValsMap();
        loadForm();
      }
      if (message.type === "populateForm") {
        populateFormFromValues(message.paramMap);
      }
    });

    function applyCase(val) {
      if (caseMode === "MONO") {
        const trimmed = val.trim();
        if (
          (trimmed.startsWith("'") && trimmed.endsWith("'")) ||
          (trimmed.startsWith('"') && trimmed.endsWith('"'))
        ) {
          return trimmed;
        }
        return trimmed.toUpperCase();
      }
      return val;
    }

    function setLabel(val) {
      const labelInput = document.getElementById("clLabel");
      if (labelInput) labelInput.value = val || "";
    }

    function getDefaultForInput(input, parms) {
      let name = input.name;
      let kwd = name;
      let qualIdx = null;
      let qualPrompt = null;
      const qualMatch = name.match(/^(.+?)_(.+)$/);
      if (qualMatch) {
        kwd = qualMatch[1];
        qualPrompt = qualMatch[2];
      }
      const parm = Array.from(parms).find(p => p.getAttribute("Kwd") === kwd);
      if (!parm) return "";
      if (qualPrompt) {
        const quals = parm.getElementsByTagName("Qual");
        for (let q = 0; q < quals.length; q++) {
          const qual = quals[q];
          if ((qual.getAttribute("Prompt") || q.toString()) === qualPrompt || qualPrompt == q.toString()) {
            if (qual.getAttribute("Dft")) return qual.getAttribute("Dft");
            if (qual.getAttribute("Min") === "0") return "";
            return null;
          }
        }
      }
      if (name.includes("_ELEM")) {
        const elemMatch = name.match(/^(.+?)_ELEM(\d+)/);
        if (elemMatch) {
          const elemIdx = parseInt(elemMatch[2], 10);
          const elems = parm.getElementsByTagName("Elem");
          if (elems[elemIdx]) {
            if (elems[elemIdx].getAttribute("Dft")) return elems[elemIdx].getAttribute("Dft");
            if (elems[elemIdx].getAttribute("Min") === "0") return "";
            return null;
          }
        }
      }
      if (parm.getAttribute("Dft")) return parm.getAttribute("Dft");
      if (parm.getAttribute("Min") === "0") return "";
      return null;
    }

    function splitUnquotedSlash(str) {
      const result = [];
      let current = '';
      let inSingle = false, inDouble = false;
      for (let i = 0; i < str.length; i++) {
        const c = str[i];
        if (c === "'" && !inDouble) inSingle = !inSingle;
        else if (c === '"' && !inSingle) inDouble = !inDouble;
        else if (c === '/' && !inSingle && !inDouble) {
          result.push(current);
          current = '';
          continue;
        }
        current += c;
      }
      result.push(current);
      return result;
    }

    function createDropdownWithCustomInput(name, dropdownVals, placeholder = "Or enter custom value", sngvalList = [], noCustomInput = false) {
      const container = document.createElement("span");
      const select = document.createElement("select");
      select.name = name;
      const sngvalSet = new Set(sngvalList);
      const sngvalOpts = dropdownVals.filter(val => sngvalSet.has(val));
      const otherOpts = dropdownVals.filter(val => !sngvalSet.has(val));
      const sngvalGroup = document.createElement("optgroup");
      sngvalGroup.label = "Single Values";
      sngvalOpts.forEach(val => {
        const opt = document.createElement("option");
        opt.value = val;
        opt.textContent = val;
        opt.dataset.sngval = "true";
        sngvalGroup.appendChild(opt);
      });
      select.appendChild(sngvalGroup);
      const otherGroup = document.createElement("optgroup");
      otherGroup.label = "Other Values";
      otherOpts.forEach(val => {
        const opt = document.createElement("option");
        opt.value = val;
        opt.textContent = val;
        otherGroup.appendChild(opt);
      });
      select.appendChild(otherGroup);
      if (sngvalOpts.length > 0) select.dataset.hasSngval = "true";
      if (!noCustomInput) {
        const customInput = document.createElement("input");
        customInput.type = "text";
        customInput.placeholder = placeholder;
        customInput.className = "clvar-input";
        customInput.id = name + "_custom";
        customInput.addEventListener("input", function () {
          if (customInput.value.trim() !== "") {
            select.selectedIndex = -1;
          }
        });
        select.addEventListener("change", function () {
          customInput.value = "";
        });
        select.dataset.customInputId = customInput.id;
        container.appendChild(select);
        container.appendChild(customInput);
      } else {
        container.appendChild(select);
      }
      return container;
    }

    function flattenParmValue(val) {
      if (typeof val === "string") {
        return [val];
      }
      if (Array.isArray(val)) {
        if (val.length > 0 && Array.isArray(val[0])) {
          return val.map(sub =>
            Array.isArray(sub) ? sub.join("/") : sub
          );
        }
        return val;
      }
      return [];
    }

    function splitCLQual(val) {
      let parts = [];
      let current = '';
      let inSingle = false, inDouble = false, parenDepth = 0;
      for (let i = 0; i < val.length; i++) {
        const c = val[i];
        if (c === "'" && !inDouble) inSingle = !inSingle;
        else if (c === '"' && !inSingle) inDouble = !inDouble;
        else if (c === '/' && !inSingle && !inDouble && parenDepth === 0) {
          parts.push(current);
          current = '';
          continue;
        }
        if (c === '(' && !inSingle && !inDouble) parenDepth++;
        else if (c === ')' && !inSingle && !inDouble && parenDepth > 0) parenDepth--;
        current += c;
      }
      parts.push(current);
      return parts;
    }

    function populateElemInputs(parm, kwd, vals, instanceIdx = 0, container = document) {
      const elems = parm ? parm.getElementsByTagName("Elem") : [];
      let splitVals;
      if (Array.isArray(vals)) {
        splitVals = vals;
      } else if (typeof vals === 'string') {
        if (isCLExpression(vals)) {
          splitVals = [vals];
        } else {
          splitVals = vals.split(' ');
        }
      } else {
        splitVals = [];
      }
      for (let e = 0; e < elems.length; e++) {
        const elemName = `${kwd}_ELEM${e}_${instanceIdx}`;
        const value = splitVals[e] !== undefined ? splitVals[e] : "";
        const select = container.querySelector(`select[name="${elemName}"]`);
        const customInput = container.querySelector(`#${elemName}_custom`);
        if (select && customInput) {
          let foundIdx = -1;
          for (let i = 0; i < select.options.length; i++) {
            if (select.options[i].value.trim().toUpperCase() === value.trim().toUpperCase()) {
              foundIdx = i;
              break;
            }
          }
          if (foundIdx !== -1 && value) {
            select.selectedIndex = foundIdx;
            customInput.value = "";
          } else if (value) {
            select.selectedIndex = -1;
            customInput.value = value;
          } else {
            select.selectedIndex = -1;
            customInput.value = "";
          }
        } else {
          const input = container.querySelector(`[name="${elemName}"]`);
          if (input) input.value = value;
        }
      }
    }

    function populateQualInputs(parm, kwd, vals, container = document) {
      const quals = parm ? parm.getElementsByTagName("Qual") : [];
      let parts;
      if (Array.isArray(vals)) {
        parts = vals;
      } else if (typeof vals === "string") {
        parts = splitCLQual(vals);
      } else {
        parts = [];
      }
      for (let q = 0; q < quals.length; q++) {
        const qName = `${kwd}_QUAL${q}`;
        const value = parts[parts.length - 1 - q] !== undefined ? parts[parts.length - 1 - q] : "";
        const select = container.querySelector(`select[name="${qName}"]`);
        const customInput = container.querySelector(`#${qName}_custom`);
        if (select && customInput) {
          let foundIdx = -1;
          for (let i = 0; i < select.options.length; i++) {
            if (select.options[i].value.trim().toUpperCase() === value.trim().toUpperCase()) {
              foundIdx = i;
              break;
            }
          }
          if (foundIdx !== -1 && value) {
            select.selectedIndex = foundIdx;
            customInput.value = "";
          } else if (value) {
            select.selectedIndex = -1;
            customInput.value = value;
          } else {
            select.selectedIndex = -1;
            customInput.value = "";
          }
        } else {
          const input = container.querySelector(`[name="${qName}"]`);
          if (input) input.value = value;
        }
      }
    }

    function populateFormFromValues(paramMap) {
      for (const [kwd, vals] of Object.entries(paramMap)) {
        const group = document.querySelector(`.parm-multi-group[data-kwd="${kwd}"]`);
        if (group) {
          let instances = group.querySelectorAll('.parm-instance');
          for (let i = 1; i < instances.length; i++) instances[i].remove();
          let splitValsArr = flattenParmValue(vals);
          for (let i = 0; i < splitValsArr.length; i++) {
            if (i > 0) {
              const addBtn = group.querySelector('.add-parm-btn');
              if (addBtn) addBtn.click();
            }
            const inst = group.querySelectorAll('.parm-instance')[i];
            if (!inst) continue;
            const parm = Array.from(parms).find(p => p.getAttribute("Kwd") === kwd);
            if (parm && parm.getElementsByTagName("Elem").length > 0) {
              populateElemInputs(parm, kwd, splitValsArr[i], i, inst);
              continue;
            }
            if (parm && parm.getElementsByTagName("Qual").length > 0) {
              populateQualInputs(parm, kwd, splitValsArr[i], inst);
              continue;
            }
            const select = inst.querySelector(`select[name="${kwd}"]`);
            const customInput = inst.querySelector(`#${kwd}_custom`);
            let value = (splitValsArr[i] !== undefined && splitValsArr[i] !== null && splitValsArr[i] !== "")
              ? splitValsArr[i].toString().trim()
              : getDefaultForInput(select, parms);
            if (select && customInput) {
              let foundIdx = -1;
              for (let j = 0; j < select.options.length; j++) {
                if (select.options[j].value.trim().toUpperCase() === (value || "").trim().toUpperCase()) {
                  foundIdx = j;
                  break;
                }
              }
              if (foundIdx !== -1 && value) {
                select.selectedIndex = foundIdx;
                customInput.value = "";
              } else if (value) {
                select.selectedIndex = -1;
                customInput.value = value;
              } else {
                select.selectedIndex = -1;
                customInput.value = "";
              }
            } else {
              const input = inst.querySelector(`[name="${kwd}"]`);
              if (input) input.value = value;
            }
          }
          handleSngvalLocking(group);
          continue;
        }
        const parm = Array.from(parms).find(p => p.getAttribute("Kwd") === kwd);
        if (parm && parm.getElementsByTagName("Elem").length > 0) {
          populateElemInputs(parm, kwd, vals, 0, document);
          continue;
        }
        if (parm && parm.getElementsByTagName("Qual").length > 0) {
          populateQualInputs(parm, kwd, vals, document);
          continue;
        }
        // --- Simple parameter ---
        const input = document.querySelector(`[name="${kwd}"], [name^="${kwd}_"]`);
        if (input) {
          input.value = Array.isArray(vals) ? vals[0] : vals;
        }
      }
      document.querySelectorAll('.elem-group').forEach(group => handleSngvalLocking(group));
    }

    function buildAllowedValsMap() {
      allowedValsMap = {};
      if (!parms) return;
      parms.forEach(parm => {
        const kwd = parm.getAttribute("Kwd");
        // --- For Parm itself ---
        let vals = [];
        // <Values>
        const values = parm.getElementsByTagName("Values");
        if (values.length > 0) {
          vals = vals.concat(Array.from(values[0].getElementsByTagName("Value")).map(v => v.getAttribute("Value")));
        }
        // <Spcval>
        const spcvals = parm.getElementsByTagName("Spcval");
        if (spcvals.length > 0) {
          vals = vals.concat(Array.from(spcvals[0].getElementsByTagName("Value")).map(v => v.getAttribute("Value")));
        }
        // <Sngval>
        const sngvals = parm.getElementsByTagName("Sngval");
        if (sngvals.length > 0) {
          vals = vals.concat(Array.from(sngvals[0].getElementsByTagName("Value")).map(v => v.getAttribute("Value")));
        }
        if (vals.length > 0 && parm.getAttribute("Rstd") !== "Y") {
          allowedValsMap[kwd] = vals.filter(Boolean);
        }
        // --- For each Elem ---
        const elems = parm.getElementsByTagName("Elem");
        for (let e = 0; e < elems.length; e++) {
          const elem = elems[e];
          let elemVals = [];
          const elemName = `${kwd}_ELEM${e}`;
          const elemValues = elem.getElementsByTagName("Values");
          if (elemValues.length > 0) {
            elemVals = elemVals.concat(Array.from(elemValues[0].getElementsByTagName("Value")).map(v => v.getAttribute("Value")));
          }
          const elemSpcvals = elem.getElementsByTagName("Spcval");
          if (elemSpcvals.length > 0) {
            elemVals = elemVals.concat(Array.from(elemSpcvals[0].getElementsByTagName("Value")).map(v => v.getAttribute("Value")));
          }
          const elemSngvals = elem.getElementsByTagName("Sngval");
          if (elemSngvals.length > 0) {
            elemVals = elemVals.concat(Array.from(elemSngvals[0].getElementsByTagName("Value")).map(v => v.getAttribute("Value")));
          }
          if (elemVals.length > 0 && elem.getAttribute("Rstd") !== "Y") {
            allowedValsMap[elemName] = elemVals.filter(Boolean);
          }
        }
        // --- For each Qual ---
        const quals = parm.getElementsByTagName("Qual");
        for (let q = 0; q < quals.length; q++) {
          const qual = quals[q];
          let qualVals = [];
          const qualName = `${kwd}_QUAL${q}`;
          const qualValues = qual.getElementsByTagName("Values");
          if (qualValues.length > 0) {
            qualVals = qualVals.concat(Array.from(qualValues[0].getElementsByTagName("Value")).map(v => v.getAttribute("Value")));
          }
          const qualSpcvals = qual.getElementsByTagName("Spcval");
          if (qualSpcvals.length > 0) {
            qualVals = qualVals.concat(Array.from(qualSpcvals[0].getElementsByTagName("Value")).map(v => v.getAttribute("Value")));
          }
          const qualSngvals = qual.getElementsByTagName("Sngval");
          if (qualSngvals.length > 0) {
            qualVals = qualVals.concat(Array.from(qualSngvals[0].getElementsByTagName("Value")).map(v => v.getAttribute("Value")));
          }
          if (qualVals.length > 0 && qual.getAttribute("Rstd") !== "Y") {
            allowedValsMap[qualName] = qualVals.filter(Boolean);
          }
        }
      });
    }
    function handleSngvalLocking(container) {
      const sngvalSelects = container.querySelectorAll('select[data-has-sngval="true"]');
      sngvalSelects.forEach(select => {
        function updateLocking() {
          const isSngval =
            select.value &&
            select.selectedIndex !== -1 &&
            select.options[select.selectedIndex].dataset.sngval === "true";

          const allInputs = Array.from(container.querySelectorAll('input, select')).filter(i => {
            if (i === select) return false;
            if (i.id && select.dataset.customInputId && i.id === select.dataset.customInputId) return false;
            return true;
          });

          if (isSngval) {
            allInputs.forEach(i => {
              i.disabled = true;
              if (i.tagName === "SELECT") i.selectedIndex = -1;
              else i.value = "";
            });
          } else {
            allInputs.forEach(i => i.disabled = false);
          }

          const multiGroup = container.closest('.parm-multi-group');
          if (multiGroup) {
            const addBtn = multiGroup.querySelector('.add-parm-btn');
            if (addBtn) addBtn.disabled = isSngval;
            if (isSngval) {
              multiGroup.querySelectorAll('.parm-instance').forEach(inst => {
                if (inst !== container) inst.style.display = "none";
              });
            } else {
              multiGroup.querySelectorAll('.parm-instance').forEach(inst => {
                inst.style.display = "";
              });
            }
          }
        }

        select.addEventListener('change', function () {
          if (select.dataset.customInputId) {
            const customInput = document.getElementById(select.dataset.customInputId);
            if (customInput) customInput.value = "";
          }
          updateLocking();
        });

        updateLocking();
      });
    }

    function createInputForType(type, name, value, len) {
      type = (type || "text").toUpperCase();
      let input;
      switch (type) {
        case "*DEC":
        case "*INT2":
        case "*INT4":
        case "*UINT2":
        case "*UINT4":
          input = document.createElement("input");
          input.type = "number";
          break;
        case "*DATE":
          input = document.createElement("input");
          input.type = "date";
          break;
        case "*TIME":
          input = document.createElement("input");
          input.type = "time";
          break;
        case "*LGL":
          input = document.createElement("input");
          input.type = "checkbox";
          input.checked = value === "1" || value === "Y" || value === "TRUE";
          break;
        case "*NULL":
          input = document.createElement("input");
          input.type = "hidden";
          break;
        case "*CMDSTR":
        case "*CMD":
          input = document.createElement("textarea");
          input.value = value;
          if (len) input.maxLength = parseInt(len, 10);
          break;
        case "*HEX":
          input = document.createElement("input");
          input.type = "text";
          input.pattern = "[0-9A-Fa-f]*";
          break;
        case "*X":
          input = document.createElement("input");
          input.type = "text";
          break;
        default:
          input = document.createElement("input");
          input.type = "text";
          break;
      }
      input.name = name;
      if (type !== "*LGL" && type !== "*NULL" && type !== "*CMDSTR" && type !== "*CMD") {
        input.value = value;
      }
      if (len && input.type !== "hidden" && input.type !== "checkbox" && input.type !== "date" && input.type !== "time" && input.type !== "number") {
        input.maxLength = parseInt(len, 10);
      }
      if (type === "*NULL") {
        input.value = "";
      }
      return input;
    }

    function isValidName(val) {
      const trimmed = val.trim();
      if (trimmed.startsWith("&")) {
        return /^[&][A-Z$#@][A-Z0-9$#@_.]{0,10}$/i.test(trimmed);
      }
      if (
        (trimmed.startsWith("'") && trimmed.endsWith("'")) ||
        (trimmed.startsWith('"') && trimmed.endsWith('"'))
      ) {
        return true;
      }
      return /^[A-Z$#@][A-Z0-9$#@_.]{0,10}$/i.test(trimmed);
    }



    function getDropdownOrCustomValue(selectElem) {
      if (selectElem && selectElem.dataset.customInputId) {
        const customInput = document.getElementById(selectElem.dataset.customInputId);
        if (customInput && customInput.value.trim() !== "") {
          return customInput.value.trim();
        } else {
          return selectElem.value;
        }
      }
      return selectElem.value;
    }

    function renderParmInstance(parm, kwd, idx, max, multiGroupDiv) {
      const type = (parm.getAttribute("Type") || "").toUpperCase();
      const prompt = parm.getAttribute("Prompt") || kwd;
      const dft = parm.getAttribute("Dft") || "";
      const len = parm.getAttribute("Len") || "";
      const required = parm.getAttribute("Min") === "1";
      const instanceId = `${kwd}_INST${idx}`;
      const div = document.createElement("div");
      div.className = "parm-instance";
      div.dataset.kwd = kwd;

      // Label
      const label = document.createElement("label");
      label.className = "form-label";
      label.textContent = prompt + (max > 1 ? ` [${idx + 1}]` : "");
      label.htmlFor = instanceId;
      div.appendChild(label);

      // ELEM (list) parameter
      if (type === "ELEM" || parm.getElementsByTagName("Elem").length > 0) {
        const elems = parm.getElementsByTagName("Elem");
        const fieldset = document.createElement("fieldset");
        fieldset.className = "elem-group";
        const legend = document.createElement("legend");
        legend.textContent = prompt;
        fieldset.appendChild(legend);

        for (let e = 0; e < elems.length; e++) {
          const elem = elems[e];
          const elemPrompt = elem.getAttribute("Prompt") || elem.getAttribute("Name") || `Element ${e + 1}`;
          const elemType = elem.getAttribute("Type") || "CHAR";
          const elemLen = elem.getAttribute("Len") || "";
          const elemName = `${kwd}_ELEM${e}_${idx}`;
          const elemDiv = document.createElement("div");
          elemDiv.className = "form-div";
          const elemLabel = document.createElement("label");
          elemLabel.className = "form-label";
          elemLabel.textContent = elemPrompt;
          elemLabel.htmlFor = elemName;
          elemDiv.appendChild(elemLabel);
          const allowedVals = allowedValsMap[elemName] || [];
          if (allowedVals.length > 0) {
            const dropdown = createDropdownWithCustomInput(elemName, allowedVals);
            elemDiv.appendChild(dropdown);
          } else {
            const elemInput = createInputForType(elemType, elemName, dft, elemLen);
            elemDiv.appendChild(elemInput);
          } fieldset.appendChild(elemDiv);
        }
        div.appendChild(fieldset);
      }
      // QUAL parameter
      else if (parm.getElementsByTagName("Qual").length > 0) {
        const quals = parm.getElementsByTagName("Qual");
        const fieldset = document.createElement("fieldset");
        fieldset.className = "qual-group";
        const legend = document.createElement("legend");
        legend.textContent = prompt;
        fieldset.appendChild(legend);

        for (let q = 0; q < quals.length; q++) {
          const qual = quals[q];
          const qualPrompt = qual.getAttribute("Prompt") || qual.getAttribute("Name") || `Qualifier ${q + 1}`;
          const qualType = qual.getAttribute("Type") || "CHAR";
          const qualLen = qual.getAttribute("Len") || "";
          const qualName = `${kwd}_QUAL${q}`;
          const qualDiv = document.createElement("div");
          qualDiv.className = "form-div";
          const qualLabel = document.createElement("label");
          qualLabel.className = "form-label";
          qualLabel.textContent = qualPrompt;
          qualLabel.htmlFor = qualName;
          qualDiv.appendChild(qualLabel);
          const allowedVals = allowedValsMap[qualName] || [];
          if (allowedVals.length > 0) {
            const dropdown = createDropdownWithCustomInput(qualName, allowedVals);
            qualDiv.appendChild(dropdown);
          } else {
            const qualInput = createInputForType(qualType, qualName, dft, qualLen);
            qualDiv.appendChild(qualInput);
          }
          fieldset.appendChild(qualDiv);
        }
        div.appendChild(fieldset);
      }
      // Simple parameter
      else {
        const allowedVals = allowedValsMap[kwd] || [];
        if (allowedVals.length > 0) {
          const dropdown = createDropdownWithCustomInput(kwd, allowedVals);
          div.appendChild(dropdown);
        } else {
          const input = createInputForType(type, kwd, dft, len);
          input.id = instanceId;
          if (required) input.required = true;
          div.appendChild(input);
        }
      }

      // Multi-instance controls
      if (max > 1 && multiGroupDiv) {
        if (idx === 0) {
          const addBtn = document.createElement("button");
          addBtn.type = "button";
          addBtn.className = "add-parm-btn";
          addBtn.textContent = "+";
          addBtn.title = "Add another instance";
          addBtn.onclick = function () {
            const instances = multiGroupDiv.querySelectorAll(".parm-instance");
            if (instances.length < max) {
              const newIdx = instances.length;
              const newDiv = renderParmInstance(parm, kwd, newIdx, max, multiGroupDiv);
              multiGroupDiv.appendChild(newDiv);
            }
          };
          div.appendChild(addBtn);
        }
        if (idx > 0) {
          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "remove-parm-btn";
          removeBtn.textContent = "-";
          removeBtn.title = "Remove this instance";
          removeBtn.onclick = function () {
            div.remove();
          };
          div.appendChild(removeBtn);
        }
      }

      return div;
    }

    // --- Main form rendering ---
    function loadForm() {
      console.log("loadForm called, xmlDoc:", xmlDoc);
      if (!xmlDoc) return;
      const form = document.getElementById("clForm");
      form.innerHTML = "";

      parms = Array.from(xmlDoc.getElementsByTagName("Parm"));

      parms.forEach(parm => {
        const kwd = parm.getAttribute("Kwd");
        const max = parseInt(parm.getAttribute("Max") || "1", 10);

        // Multi-instance group
        if (max > 1) {
          const multiGroupDiv = document.createElement("div");
          multiGroupDiv.className = "parm-multi-group";
          multiGroupDiv.dataset.kwd = kwd;
          multiGroupDiv.dataset.max = max;
          // Render first instance
          multiGroupDiv.appendChild(renderParmInstance(parm, kwd, 0, max, multiGroupDiv));
          form.appendChild(multiGroupDiv);
        } else {
          // Single instance
          form.appendChild(renderParmInstance(parm, kwd, 0, 1, null));
        }
      });
    }


    // --- SUBMIT HANDLER ---
    document.getElementById("submitBtn").addEventListener("click", e => {
      try {
        e.preventDefault();
        if (!xmlDoc) return;
        const values = {};
        const qualGroups = {};

        // --- 1. MULTI-INSTANCE (MAX > 1) PARAMETERS ---
        document.querySelectorAll(".parm-multi-group").forEach(group => {
          const kwd = group.dataset.kwd;
          const parm = Array.from(parms).find(p => p.getAttribute("Kwd") === kwd);
          if (!parm) return;
          let max = parseInt(group.dataset.max, 10);
          const instances = group.querySelectorAll(".parm-instance");
          let instanceVals = [];
          instances.forEach((inst, idx) => {
            if ((parm.getAttribute("Type") || "").toUpperCase() === "ELEM") {
              const elems = parm.getElementsByTagName("Elem");
              let elemVals = [];
              for (let e = 0; e < elems.length; e++) {
                const elemName = `${kwd}_ELEM${e}_${idx}`;
                const input = inst.querySelector(`[name="${elemName}"]`);
                let val = input ? input.value : "";
                if (val === "" || val === undefined || val === null || val === "*N") continue;
                const elemType = (elems[e].getAttribute("Type") || "").toUpperCase();
                elemVals.push(val);
              }
              const filtered = elemVals.filter(v => v !== "*N" && v !== "" && v !== "''");
              if (filtered.length > 0) {
                instanceVals.push(filtered.join(" "));
              }
            } else {
              let input = inst.querySelector(`select[name^="${kwd}_"]`) || inst.querySelector(`select[name="${kwd}_${idx}"]`) || inst.querySelector(`select[name="${kwd}"]`);
              let val = "";
              if (input) {
                val = getDropdownOrCustomValue(input);
              } else {
                input = inst.querySelector(`[name^="${kwd}_"]`) || inst.querySelector(`[name="${kwd}_${idx}"]`) || inst.querySelector(`[name="${kwd}"]`);
                val = input ? input.value : "";
              }
              if (val === "" || val === undefined || val === null) return;
              const parmType = parm && parm.getAttribute("Type") ? parm.getAttribute("Type").toUpperCase() : "";
              if (parmType === "NAME" && val) val = val.toUpperCase();
              instanceVals.push(val);
            }
          });
          if (instanceVals.length > 0) {
            values[kwd] = instanceVals;
          } else if (originalParamMap.hasOwnProperty(kwd)) {
            let orig = originalParamMap[kwd];
            if (Array.isArray(orig)) {
              values[kwd] = orig;
            } else if (typeof orig === "string") {
              values[kwd] = orig.trim().split(/\s+/);
            } else {
              values[kwd] = String(orig);
            }
          }
        });

        // --- 2. SINGLE-INSTANCE PARAMETERS (not in multi-groups) ---
        const form = document.getElementById('clForm');
        const inputs = form.querySelectorAll('input, select, textarea');
        inputs.forEach(i => {
          if (i.closest('.parm-multi-group')) return;
          if (!i.name) return;
          let parmType = "CHAR";
          let parmElem = null;
          for (let p = 0; p < parms.length; p++) {
            const kwd = parms[p].getAttribute("Kwd");
            if (i.name.startsWith(kwd)) {
              parmElem = parms[p];
              break;
            }
          }
          if (!parmElem) return;
          const parmKwd = parmElem.getAttribute("Kwd");
          if (parmElem.hasAttribute("Type")) parmType = parmElem.getAttribute("Type").toUpperCase();
          let val = i.value;
          if (i.tagName === "SELECT" && i.dataset.customInputId) {
            val = getDropdownOrCustomValue(i);
          }
          const qualMatch = i.name.match(/^(.+?)_(.+)$/);
          if (qualMatch) {
            const parmName = qualMatch[1];
            const qualName = qualMatch[2];
            if (!qualGroups[parmName]) qualGroups[parmName] = [];
            qualGroups[parmName].push({ qual: qualName, value: val });
            return;
          }
          if (i.name.match(/_ELEM\d+$/)) {
            values[i.name] = val;
            return;
          }
          let dft = "";
          if (parmElem && parmElem.hasAttribute("Dft")) dft = parmElem.getAttribute("Dft");
          const wasInOriginal = originalParamMap.hasOwnProperty(parmKwd);
          if (
            (val !== "" && val !== dft && val !== "''" && val !== '""')
          ) {
            values[parmKwd] = val;
          } else if (wasInOriginal) {
            values[parmKwd] = originalParamMap[parmKwd];
          }
        });

        // --- 3. ELEM PARAMETER ASSEMBLY (single instance) ---
        for (let i = 0; i < parms.length; i++) {
          const parm = parms[i];
          const kwd = parm.getAttribute("Kwd");
          if ((parm.getAttribute("Type") || "").toUpperCase() === "ELEM" && !document.querySelector(`.parm-multi-group[data-kwd="${kwd}"]`)) {
            const elems = parm.getElementsByTagName("Elem");
            let elemVals = [];
            for (let e = 0; e < elems.length; e++) {
              const elemName = `${kwd}_ELEM${e}`;
              const elemNameWithIdx = `${kwd}_ELEM${e}_0`;
              const input = document.querySelector(`[name="${elemName}"]`) || document.querySelector(`[name="${elemNameWithIdx}"]`);
              let val = input ? input.value : "";
              if (val === "" || val === undefined || val === null || val === "*N") continue;
              const elemType = (elems[e].getAttribute("Type") || "").toUpperCase();
              elemVals.push(val);
            }
            const filtered = elemVals
              .filter(v => v !== "*N" && v.trim() !== "" && v !== "''");
            if (filtered.length > 0) {
              values[kwd] = filtered; // <-- Send as array, not joined string
            } else if (originalParamMap.hasOwnProperty(kwd)) {
              let orig = originalParamMap[kwd];
              if (Array.isArray(orig)) {
                values[kwd] = orig;
              } else if (typeof orig === "string") {
                values[kwd] = orig.trim().split(/\s+/); // <-- Split to array
              } else {
                values[kwd] = [String(orig)];
              }
            }
          }
        }

        // --- 4. QUAL PARAMETER ASSEMBLY (single instance) ---
        for (const parmName in qualGroups) {
          const parm = Array.from(parms).find(p => p.getAttribute("Kwd") === parmName);
          if (!parm || !parm.getElementsByTagName("Qual").length) continue;
          const parts = qualGroups[parmName]
            .sort((a, b) => a.qual.localeCompare(b.qual))
            .reverse()
            .map(q => q.value)
            .filter(val => val !== "");
          if (parts.length > 0) {
            values[parmName] = parts;
          } else if (originalParamMap.hasOwnProperty(parmName)) {
            values[parmName] = originalParamMap[parmName];
          }
        }

        // --- 5. FINAL COMMAND ASSEMBLY ---
        let cmdString = cmdName;
        for (const [key, value] of Object.entries(values)) {
          cmdString += ` ${key}(${Array.isArray(value) ? value.join(" ") : value})`;
        }
        const labelInput = document.getElementById("clLabel");
        const labelVal = labelInput && labelInput.value.trim();
        if (labelVal) {
          cmdString = `${labelVal.toUpperCase()}: ${cmdString}`;
        }
        console.log('[clPrompter] Submitting Final cmdName:', cmdName);
        console.log('[clPrompter] Submitting Final cmdString:', cmdString);
        console.log('[clPrompter] Submitting Final values:', values);
        vscode.postMessage({ type: "submit", cmdName, values });
      } catch (err) {
        console.error("[clPrompter] Error in submit handler:", err);
        alert("An error occurred: " + err.message);
      }
    });

    function isCLExpression(val) {
      const ops = ['*CAT', '*TCAT', '*BCAT', '*EQ', '*NE', '*LT', '*LE', '*GT', '*GE'];
      const trimmed = val.trim().toUpperCase();
      if (trimmed.startsWith('(') && trimmed.endsWith(')')) return true;
      if (ops.some(op => trimmed.includes(op))) return true;
      if (/%[A-Z][A-Z0-9]*\s*\(/i.test(trimmed)) return true;
      if (/&[A-Z][A-Z0-9]*\s*[*%]/i.test(trimmed)) return true;
      return false;
    }

    document.getElementById("clForm").addEventListener("keydown", function (e) {
      if (e.key === "Enter") {
        e.preventDefault();
        document.getElementById("submitBtn").click();
      }
    });

    document.getElementById("cancelBtn").addEventListener("click", e => {
      e.preventDefault();
      vscode.postMessage({ type: "cancel" });
    });

    window.addEventListener('DOMContentLoaded', () => {
      vscode.postMessage({ type: 'webviewReady' });
    });
  </script>
</body>

</html>